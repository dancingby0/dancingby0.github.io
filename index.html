
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>dancingby&#39;s home</title>
    <meta name="author" content="dancingby" />
    <meta name="description" content="" />
    <meta name="keywords" content="blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>DANCINGBY&#39;S HOME</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;DANCINGBY&#39;S HOME</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>dancingby&#39;s home</h1>
                <h3>dancingbyのblogs</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/09/25/Web-%E4%B8%80/">
        <h2 class="post-title">Web(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>使用SpringBoot开发一个web应用,当浏览器发起&#x2F;hello后,给浏览器返回字符串”hello world”</p>
<p>步骤</p>
<ol>
<li>创建springboot工程</li>
</ol>
<p>选择SpringInitializr</p>
<p>选定Spring Web</p>
<ol start="2">
<li>定义HelloController类,添加hello,并添加注解</li>
</ol>
<pre><code class="java">@RestController
public class HelloController&#123;

    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        System.out.println(&quot;hello world&quot;);
        return &quot;hello world&quot;;
    &#125;
&#125;
</code></pre>
<p>springboot启动类和controller包需要在同一个目录下</p>
<ol start="3">
<li>运行测试</li>
</ol>
<h2 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h2><p>规定浏览器和服务器之间数据传输的规则</p>
<ol>
<li><p>基于TCP;面向连接,安全(三次握手)</p>
</li>
<li><p>基于请求-响应模型: 一次请求对应一次相应</p>
</li>
<li><p>HTTP是无状态协议: 对于事物处理没有记忆能力.每次请求-响应都是独立</p>
</li>
</ol>
<p>缺点: 多次请求间不能共享数据</p>
<p>优点: 速度快</p>
<h3 id="HTTP请求数据格式"><a href="#HTTP请求数据格式" class="headerlink" title="HTTP请求数据格式"></a>HTTP请求数据格式</h3><p>请求行+ 请求头</p>
<p>GET &#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1 HTTP&#x2F;1.1 请求行</p>
<p>请求方式: GET&#x2F;POST<br>资源路径<br>协议 HTTP&#x2F;1.1</p>
<p>请求头:</p>
<p>第二行开始,格式key:value</p>
<p>Host:  请求主机名</p>
<p>User-Agent: 浏览器版本</p>
<p>Accept: 能接受的资源类型</p>
<p>Accept-Language: 表示浏览器偏好语言</p>
<p>Accept-Encoding: 浏览器偏好语言</p>
<p>Content-Type: 请求主体数据类型</p>
<p>Content-Length: 请求主体大小</p>
<p>用于兼容性处理</p>
<p>GET: 请求参数在请求行中,大小有限制</p>
<p>POST: 请求参数在请求体中,POST请求大小没有限制</p>
<h3 id="HTTP相应数据格式"><a href="#HTTP相应数据格式" class="headerlink" title="HTTP相应数据格式"></a>HTTP相应数据格式</h3><p>响应行: 响应数据第一行(协议,状态码,描述)</p>
<p>响应头: 第二行开始: key: value</p>
<p>响应体: 最后一部分,存放响应数据</p>
<pre><code class="http">HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Date: Tue, 10 May 2022 07:51:07 GMT
Keep-Alive: timeout=60
Connection: keep-alive

[&#123;id:1,brandName:&quot;Alibaba&quot;,companyName:&quot;腾讯公司&quot;&#125;]
</code></pre>
<p>状态码:</p>
<p>1xx 响应中-临时状态码,</p>
<p>2xx 成功</p>
<p>3xx 重定向-重定向至其他地方,让客户端再发起一次请求完成整个处理</p>
<p>4xx 客户端错误 责任在客户端,如禁止访问,客户端未被授权,请求不存在的资源</p>
<p>5xx 服务器错误 责任在服务端,如程序抛出异常</p>
<p>Content-Type: 相应内容类型</p>
<p>Content-Length: 响应内容长度</p>
<p>Content-Encoding: 该响应压缩算法</p>
<p>Cache-Control: 客户端应当如何缓存,如max-age&#x3D;300表示最多缓存300s</p>
<p>Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie</p>
<h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><pre><code class="java">public class Server&#123;
    public static void main(String[] args) throws IOException&#123;
        ServerSocket ss = new ServerSocket(8080); // 监听指定端口
        While(true)&#123;
            Socket sock = ss.accept(); // 接受客户端请求
            System.out.println(&quot;connect from&quot; + sock.getRemoteSocketAddress());

            // 开启线程处理请求
            Thread t = new Handler(sock);
            t.start();
        &#125;
    &#125;
&#125;

class Handler extends Thread&#123;
    Socket sock;

    public void run()&#123;
        try(
            InputStream input = this.sock.getInputStream(); // 获取输入流
            OutputStream output = this.sock.getOutputStream(); // 获取输出流
            handle(input,output);
        )
        catch(Exception e)&#123;
            try&#123;
                this.sock.close();
            &#125;
            catch (IOException ioe)&#123;

            &#125;
        &#125;
    &#125;
    private void handle(InputStream input,OutputStream output) throws IOException&#123;
        // 对输入流和输出流进行包装
        BufferedReader reader = new BufferedReader(new InputStreamReader(input,StandardCharsets.UTF-8));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output,StandardCharsets.UTF-8));

        // 读取HTTP请求
        boolean requestOk = false;
        String first = reader.readLine(); // 请求行
        if(first.startWith(&quot;GET / HTTP/1.&quot;))&#123;
            requestOk = true;
        &#125;

        while(true)&#123;
            String header = reader.readLine();
            if(header.isEmpty())&#123;
                break; // 读完了
            &#125;
        &#125;

        if(!requestOk)&#123;
            // 错误响应
            writer.write(&quot;HTTP/1.0 404 NotFound\r\n&quot;);
            ...
        &#125;else&#123;
            // 成功响应
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果完全自己去解析,非常繁琐</p>
<p>Tomcat WebLogic等都是为了封装简化这些操作产生的</p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>是一个软件程序,对HTTP协议操作进行封装,程序员则不需要对协议进行操作,让Web开发更加便捷</p>
<p>起步依赖:</p>
<p>spring-boot-starter-web: 包含web应用开发所需要的常见依赖</p>
<p>spring-boot-starter-test: 包含单元测试所需要的常见依赖</p>
<p>官方提供的starter</p>
<p>所有springboot都继承自父工程</p>
<p>Tomcat是servlet容器,它识别servlet;而DispatcherServlet实现了Servlet接口(即tomcat可以识别DispatcherServlet);</p>
<p>从客户端传来的请求都会经过DispatcherServlet ,再给XxxController处理,处理完毕后再把响应传给DispatcherServlet,再给客户端</p>
<p>DispatcherServlet在Springboot中是核心控制器&#x2F;前端控制器</p>
<p>解析的所有信息都封装入HttpServletRequest对象中(请求对象)</p>
<p>响应的信息封装入HttpServletResponse对象中(响应对象)</p>
<p>请求:</p>
<h3 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h3><p>一般后端分为三层架构:</p>
<h4 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层:"></a>Controller层:</h4><p>控制层:直接与客户端进行交互,用于接收请求和响应</p>
<ol>
<li><p>接收,解析请求</p>
</li>
<li><p>调用服务层</p>
</li>
<li><p>返回响应</p>
</li>
<li><p>处理异常</p>
</li>
</ol>
<p>在Spring框架中，控制层通常使用@Controller或@RestController注解。@Controller用于返回视图页面，而@RestController是@Controller和@ResponseBody的组合，主要用于RESTful API开发，返回的是JSON或XML数据。</p>
<pre><code class="java">@RestController
@RequestMapping(&quot;/users&quot;)
public class UserController &#123;
    @Autowired
    private UserService userService;
 
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public ResponseEntity&lt;User&gt; getUserById(@PathVariable Integer id) &#123;//id为路径参数
        User user = userService.getUserById(id);//调用服务层获取用户信息
        return Result.success(user); //返回json格式数据和用户信息
    &#125;
 
    @PostMapping
    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) &#123;
        User newUser = userService.saveUser(user);//调用服务层创建新用户
        return Result.success(newUser);//返回json格式数据和新用户信息
    &#125;
    //负责进行异常处理
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity&lt;String&gt; handleUserNotFound(UserNotFoundException ex) &#123;
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    &#125;
&#125;
</code></pre>
<p>其中,Result类是用来统一返回类的:</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result &#123;
    private Integer code;//响应码，1 代表成功; 0 代表失败
    private String msg;  //响应信息 描述字符串
    private Object data; //返回的数据
    //增删改 成功响应
    public static Result success()&#123;
        return new Result(1,&quot;success&quot;,null);
    &#125;
    //查询 成功响应
    public static Result success(Object data)&#123;
        return new Result(1,&quot;success&quot;,data);
    &#125;
    //失败响应
    public static Result error(String msg)&#123;
        return new Result(0,msg,null);
    &#125;
&#125;
</code></pre>
<h4 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h4><p>服务层（Service）是整个应用程序的核心部分，负责处理所有的业务逻辑。它在控制层和数据访问层之间起到中介作用，封装了业务流程，并协调DAO层的数据访问操作。</p>
<p>1.业务逻辑实现：将业务需求转化为可执行的逻辑操作，包括数据的校验、转换、计算等。</p>
<p>2.事务管理：在处理涉及多个数据库操作的业务时，确保这些操作要么全部成功，要么全部失败（即事务的原子性）。<br>3.调用DAO层：与数据访问层（DAO层）交互，完成数据的增删改查等各种操作。</p>
<p>4.封装复杂逻辑：将复杂的业务流程封装在服务层，控制层只需要调用相应的服务方法，而不关心其内部实现细节。</p>
<p>5.集成其他服务：在大型系统中，服务层可能还负责与外部服务的集成，例如调用其他微服务、消息队列、第三方API等。</p>
<p>典型的服务层类通常包含多个业务方法，这些方法通过注入DAO层对象（通过注解@Autowired 和 @Resource实现</p>
<pre><code class="java">@Service
public class UserService &#123;
    @Autowired
    private UserDao userDao;
 
    @Transactional
    public User getUserById(Integer id) &#123;
        return userDao.getById(id);//调用Dao层通过ID查找用户
    &#125;
 
    @Transactional
    public User saveUser(User user) &#123;
        //业务逻辑部分代码：如检查用户名是否已存在，设置用户创建时间等
        return userDao.save(user);
    &#125;
 
    //其他处理方法代码
&#125;
</code></pre>
<h4 id="DAO层"><a href="#DAO层" class="headerlink" title="DAO层"></a>DAO层</h4><p>1.CRUD 操作：提供增删改查数据库记录的操作。</p>
<p>2.数据库连接管理：管理与数据库的连接以及连接池的使用（在现代框架中，这通常由ORM工具或框架自动管理）。</p>
<p>3.数据转换：将数据库中的数据转换为应用程序中的对象（DTO，Data Transfer Object），以及将对象转换为适合存储在数据库中的格式。</p>
<p>4.查询封装：将复杂的数据库查询封装为易于调用的方法，因此控制层(Controller)和服务层(Service)不会直接接触SQL语句，即不必关心具体的数据库实现。</p>
<p>DAO层通常使用@Repository注解，并且依赖于ORM（如Hibernate或JPA）来简化数据访问。DAO层可以直接使用JPA的JpaRepository接口，或者自定义查询方法。</p>
<pre><code class="java">@Repository
public interface UserDao extends JpaRepository&lt;User, Long&gt; &#123;
    // 继承JpaRepository后，自动获得基本的CRUD操作
    // 自定义查询方法
    User getById(Integer id);
 
     // 自定义的JPQL或Native SQL查询
    @Query(&quot;SELECT u FROM User u WHERE u.email = ?1&quot;)
    User findByEmail(String email);
&#125;
</code></pre>
<p>Controller 层– &gt;Service 层– &gt;DAO 层：</p>
<p>控制层负责接收客户端请求并传递给服务层，服务层在处理业务逻辑后，可能需要访问数据，于是调用DAO层进行数据库操作。</p>
<p>DAO 层–&gt;Service 层– &gt; Controller 层：</p>
<p>DAO层将数据返回给服务层，服务层进行必要的处理后，将结果返回给控制层，最终控制层将响应发送给客户端。</p>
<h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p>IOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想</p>
<p><strong>控制</strong>：IOC意味着将你设计好的对象交给IOC容器控制，而不是传统的在你的对象内部直接控制；</p>
<p>IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；</p>
<p>谁控制谁？当然是IOC容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
<p><strong>反转</strong>：传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；</p>
<p>反转则是由IOC容器来帮忙创建及注入依赖对象；</p>
<p>由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<p>@Component 声明bean的基础注解 不属于三层中时,使用</p>
<p>@Controller 标注在控制器类上</p>
<p>@Service 标注在业务类上</p>
<p>@Repository 标注在数据访问类上(因为有mybatis,用的少)</p>
<h4 id="Bean组件扫描"><a href="#Bean组件扫描" class="headerlink" title="Bean组件扫描"></a>Bean组件扫描</h4><p>声明Bean的四个注解,若想要生效则要被组件扫描注解@ComponentScan扫描</p>
<p>@ComponentScan注解虽然没有被显示配置,但已经包含在启动类声明注解@SpringBootApplication中,默认扫描范围是启动类所在包及其子包</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>@Autowired注解,默认按照类型进行: 如果存在多个相同类型的bean,就会报错(如有两个IdDao父类的bean)</p>
<p>解决方案:</p>
<p>@Primary</p>
<p>加上这个,如果存在多个bean,则只会令有@Primary注解的bean生效</p>
<p>@Qualifier</p>
<p>在@Autowired注解的位置加上@Qualifier,指定要添加的bean,如@Qualifier(“empServiceA”)</p>
<p>@Resource<br>或者直接不用@Autowired,而直接使用@Resorce(name&#x3D;”empServiceB”)即可</p>
<p>@Resource与@Autowired区别:</p>
<p>@Autowired是spring提供的,而@Resource是JDK提供的</p>
<p>@Autowired是按照类型注入,@Resource是按照名称注入</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/25/Web-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/25/Java%E6%9D%82%E9%A1%B9-%E4%B8%80/">
        <h2 class="post-title">Java杂项(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/25/Java%E6%9D%82%E9%A1%B9-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/25/JUC%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">JUC学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/25/JUC%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/24/Lombok-Junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/">
        <h2 class="post-title">Lombok,Junit,反射,注解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><p>进行代码测试,即进行白箱测试</p>
<p>建议:</p>
<ol>
<li>测试类名: CalculatorTest</li>
<li>包名: xxx.xxx.xxx.xx.test cn.itcast.test</li>
</ol>
<p>定义测试方法:</p>
<p>可以独立运行</p>
<ol>
<li>方法名: test测试方法名 testAdd</li>
<li>返回值 void</li>
<li>形参列表 空</li>
<li>加上@Test注解</li>
</ol>
<p>判定结果 红色成功,绿色失败;一般使用断言操作处理操作</p>
<p>在测试方法中进行断言,断言结果为需要的结果,如果断言失败,则说明程序有问题</p>
<pre><code class="java">Assert.assertEquals(a+b,result); // 如果与期望的值不同,则报错
</code></pre>
<p>常见注解:</p>
<p>@Test 表明该方法是测试方法</p>
<pre><code class="java">public class CalculatorTest&#123;
    @Before // 说明在所有测试方法执行前都会调用该方法(用于申请资源)
    public void init()&#123;
        System.out.println(&quot;init...&quot;);
    &#125;
    @After // 在所有测试方法执行后都会调用该方法(用于释放资源)
    public void close()&#123;
        System.out.println(&quot;close...&quot;);
    &#125;

    @Test
    public void testAdd()&#123;
        Calculator c = new Calculator();
        int result = c.sub(1,2);
        Assert.assertEquals(3,result); // 即便失败,还是会执行close方法
    &#125;
&#125;
</code></pre>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>框架设计的灵魂</p>
<p>框架: 半成品软件(简化编码)</p>
<p>反射:将类的各个组成部分</p>
<p>好处:</p>
<ol>
<li><p>在程序运行中,可以操作这些对象</p>
</li>
<li><p>可以解耦,提高程序的可拓展性</p>
</li>
</ol>
<p>获取class对象(字节码对象)的方式</p>
<ol>
<li><p>Class.forName(“全类名”): 将字节码文件加载进内存,返回class对象 (源代码阶段) 多用于配置文件,将类名定义于配置文件中,读取文件加载类</p>
</li>
<li><p>类名.class : 通过类名的属性获取 (类对象阶段) 多用于参数传递</p>
</li>
<li><p>对象.getClass() : getClass()方法在Object类中定义 (Runtime时阶段) 多用于对象获取字节码方式</p>
</li>
</ol>
<p>结论: 同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次; <strong>不管使用什么方式加载,都是同一个对象</strong></p>
<p>&#x2F;&#x2F; java.lang.ClassNotFoundException: 无法找到类(类名可能写错了)</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Class对象功能"><a href="#Class对象功能" class="headerlink" title="Class对象功能:"></a>Class对象功能:</h3><p>获取功能:</p>
<ol>
<li>成员变量们<ul>
<li>Field[] getFields() &#x2F;&#x2F; 获取可访问的公共字段(public),包括父类</li>
<li>Field getField(String name) &#x2F;&#x2F; 获取指定名称的公共字段,</li>
<li>Field[] getDeclaredFields() &#x2F;&#x2F; 获取可访问的所有字段(不考虑修饰符),不包括父类</li>
<li>Field getDeclaredField(String name) &#x2F;&#x2F;</li>
</ul>
</li>
<li>构造方法们</li>
</ol>
<p>同上,详见文档</p>
<ol start="3">
<li><p>获取成员方法们</p>
</li>
<li><p>类名等</p>
</li>
</ol>
<pre><code class="java">Field[] fields = personClass.getFields();
</code></pre>
<h3 id="字段功能"><a href="#字段功能" class="headerlink" title="字段功能"></a>字段功能</h3><p>Field 成员变量</p>
<ol>
<li>设置值</li>
</ol>
<p>void set(Object obj, Object value) &#x2F;&#x2F; 对于特定obj的字段设置value值</p>
<ol start="2">
<li>获取值</li>
</ol>
<ul>
<li>get(Object obj)</li>
</ul>
<ol start="3">
<li>忽略访问权限修饰符安全检查<br>setAccessible(true): 暴力反射(忽略了private这种,破坏封装)</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>创建对象</p>
<pre><code class="java">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) // 获取特定的构造方法 同理,declared可以获取私有的构造器,但也需要调用构造器的setAccessible进行暴力反射

T newInstance(Object... initargs)// 通过构造方法创建实例
</code></pre>
<p>如果使用空参,操作可以简化:Class对象的newInstance方法</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Method: 方法对象</p>
<p>Object invoke(Object obj, Object… args) &#x2F;&#x2F; 对obj执行特定方法</p>
<p>获取方法名称:</p>
<p>String getName() &#x2F;&#x2F; 获取方法名</p>
<pre><code class="java">// 获取指定名称方法
Method eat_method = personClass.getMethod(&quot;eat&quot;);
Person p = new Person();
eat_method.invoke(p); // 空参方法

Method[] methods = personClass.getMethods();
for(Method method : methods)&#123;
    System.out.println(method.getName());
&#125;
</code></pre>
<p>示例:</p>
<pre><code class="java">Constructor constructor = personClass.getConstructor(String.class,int.class);
Object person = constructor.Instance(&quot;张三&quot;,23);
Object person1 = personClass.newInstance();
</code></pre>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需求:</p>
<p>创建框架,可以帮我们创建任意类的对象,并执行其中任意方法</p>
<p>实现:</p>
<ol>
<li><p>配置文件</p>
</li>
<li><p>反射</p>
</li>
</ol>
<p>步骤:</p>
<ol>
<li><p>将需要创建的对象全类名和需要执行的方法定义在配置文件中</p>
</li>
<li><p>在程序中加载读取配置文件</p>
</li>
<li><p>使用反射技术加载类文件进入内存,创建对象,执行方法</p>
</li>
</ol>
<pre><code class="ini">className=cn.itcast.domain.Person
methodName=eat
</code></pre>
<pre><code class="java">public class ReflectTest&#123;
    public static void main(String[] args) throws Exception&#123;
        Properties pro = new Properties();
        ClassLoader classLoader = ReflectTest.class.getClassLoader(); // 获取class目录下类加载器
        InputSteam is =  classLoader.getResourceAsStream(&quot;pro.properties&quot;);
        pro.load(is);
        String className = pro.getProperty(&quot;className&quot;);
        String methodName = pro.getProperty(&quot;methodName&quot;);

        Class cls = Class.forName(className);
        Object obj = cls.newInstance();

        Method method = cls.getMethod(methodName);

        method.invoke(obj);
    &#125;
&#125;
</code></pre>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>概念:</p>
<p>用文字描述程序,给程序员看的;JDK1.5之后才有</p>
<p>使用@注解名称</p>
<p>作用分类:</p>
<ol>
<li><p>编写文档(生成doc文档)</p>
</li>
<li><p>代码分析(使用反射)</p>
</li>
<li><p>编译检查(Override),让编译器能够实现基本的编译检查</p>
</li>
</ol>
<pre><code class="java">/**
 * @author test
 * @since 1.5
 */
public class Demo1&#123;

    /**
     * 计算两数和
     * @param a 整数
     * @param b 整数
     * @return 两数和
     */
    public int add(int a,int b)&#123;
        return a + b;
    &#125;
&#125;
</code></pre>
<pre><code class="bash">javadoc Demo1.java # 生成java文档
</code></pre>
<h2 id="JDK预定义注解"><a href="#JDK预定义注解" class="headerlink" title="JDK预定义注解"></a>JDK预定义注解</h2><ul>
<li>@Override: 检测该注解标注的方法是否继承自父类(父接口)</li>
<li>@Deprecated: 将该注解标注的内容,表示已过时</li>
<li>@SuppressWarnings: 压制警告</li>
<li>@Generated: 表示该代码是由工具自动生成的</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>格式:</p>
<p>元注解<br>public @interface 注解名称()</p>
<p>本质:</p>
<p>注解本质上就是一个接口,默认继承自Annotation包(通过反编译得到) 因此操作和接口相同</p>
<p>public interface MyAnno extends java.lang.annotation.Annotation{}</p>
<p>属性:</p>
<p>接口可以定义的成员方法</p>
<p>要求:</p>
<p>返回值类型:</p>
<ol>
<li><p>基本数据类型</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举</p>
</li>
<li><p>注解</p>
</li>
<li><p>以上类型的数组</p>
</li>
</ol>
<p>定义了属性(抽象方法),在使用时需要给属性赋值</p>
<p>使用default关键字给属性默认初始化值,则使用注解时可以不赋值</p>
<p>如果只有一个属性需要赋值,且名称是value,则名称可以省略,@SuppressWarnings(‘all’),这个all就是给value赋值</p>
<p>数组赋值时,需要用大括号;如果只有一个值,大括号可以省略</p>
<p>元注解:</p>
<p>用于描述注解的 注解(就是一个注解,但是它用来描述注解)</p>
<p>@Target: 描述注解能够作用的位置</p>
<p>仅有value属性, 设置ElementType枚举(查看源代码即可)</p>
<p>取值:</p>
<ul>
<li>ElementType.TYPE: 类上</li>
<li>ElementType.METHOD: 作用于方法上</li>
<li>ElementType.FIELD: 作用于成员变量上</li>
</ul>
<p>@Retention: 描述注解被保留的阶段(有三个阶段,源码,Class,Runtime阶段)</p>
<ul>
<li>一般自定义注解取RUNTIME</li>
</ul>
<p>@Documented: 描述注解是否被抽取至api文档中</p>
<p>@Inherited: 描述注解是否被子类继承</p>
<h2 id="使用-解析-注解"><a href="#使用-解析-注解" class="headerlink" title="使用(解析)注解"></a>使用(解析)注解</h2><pre><code class="java">@SuppressWarnings(&quot;all&quot;) // 需要传参,一般传all

public @interface MyAnno&#123;
    public abstract String show();
    int show1();
    String show2() default &quot;张三&quot;; // 默认张三
    Person per(); // 返回枚举类型

    String[] strs()

    int value();

&#125;

@MyAnno(show1 = 1,show2 = &quot;2&quot;,per = Person.p1,strs = &#123;&quot;aaa&quot;,&quot;bbb&quot;&#125; ) // 使用时像属性,需要赋值
</code></pre>
<pre><code class="java">
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)

</code></pre>
<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>简介:</p>
<p>Lombok是一个Java库,能够自动插入编辑器并构建工具,简化Java开发</p>
<p>他用注解进行提高代码可读性和开发效率(即只需要在Java类上添加相应注解,不需要手动编写相应代码)</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="Getter和-Setter"><a href="#Getter和-Setter" class="headerlink" title="@Getter和@Setter"></a>@Getter和@Setter</h3><p>自动生成类的getter和setter(在源代码时)</p>
<p>@Getter在类时,给所有生成getter</p>
<p>@Getter在属性时,给该字段生成getter </p>
<p>布尔类型的getter为isXxx</p>
<p>可以设置AccessLevel设置访问权限</p>
<p>如果想要让某个字段不设置getter,则@Getter(AccessLevel.NONE)</p>
<p>可以给getter等加上自定义注解</p>
<p>@Getter(onMethod_ &#x3D; { @Deprecated }) &#x2F;&#x2F; 为getter加上自定义注解</p>
<p>lazy: 懒初始化</p>
<p>如<br>@Getter(lazy &#x3D; true)<br>private final String name &#x3D; “小明”; &#x2F;&#x2F; 如果懒初始化,则说明尽可能晚地赋值,即只有需要get时才会赋值, 即懒汉式单例模式</p>
<p>lazy使用场景:</p>
<p>一个字段通过initValue赋予,但是不希望该方法在类创建时就执行</p>
<p>此外,如果自行编写了相应的getter或setter(根据命名规则判定),则不会被注解覆盖,也不会生成</p>
<h3 id="构造方法相关"><a href="#构造方法相关" class="headerlink" title="构造方法相关"></a>构造方法相关</h3><p>@AllArgsConstructor</p>
<p>全参构造器,加在类上</p>
<p>staticName 生成静态构造方法(即该构造方法被private,需要通过该静态方法进行调用) (单例)</p>
<p>onConstructor 用于添加其他注解</p>
<p>access 访问级别</p>
<p>@NoArgsConstructor</p>
<p>无参构造器</p>
<p>如果存在final变量,则需要force &#x3D; true(直接赋值默认值)</p>
<p>@RequiredArgsConstructor</p>
<p>生成需要部分生成的构造</p>
<p>为所有需要final的字段生成构造方法</p>
<h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>@ToString</p>
<p>includeFieldNames 是否打印字段名字</p>
<p>callSuper 不仅生成当前类的,并且使用父类的toString拼接</p>
<p>doNotUseGetters 默认尽可能使用get获取字段值</p>
<p>onlyExplicitlyIncluded(rank &#x3D; 1) 白名单模式,开启后则只为加上@ToString.Include注解的内容生成,rank为优先级,越大优先级越高</p>
<p>@ToString.Exclude 注解里的注解(因为接口可以套接口),黑名单模式,排除</p>
<p>同时可以对方法生效</p>
<h3 id="HashCode"><a href="#HashCode" class="headerlink" title="HashCode"></a>HashCode</h3><p>@EqualsAndHashCode &#x2F;&#x2F; 自动生成equals重写</p>
<p>重写equals时必须重写hashCode,因为集合中使用哈希</p>
<p>cacheStrategy</p>
<p>可能每次调用时都要重复计算哈希值,浪费性能,因此缓存hash码,默认不启用(但如果其中字段值可能发生变化,则不建议使用,因为它只计算一次,后续是返回第一次计算的哈希码)</p>
<p>@EqualsAndHashCode.Include(replaces &#x3D; 属性名) &#x2F;&#x2F; 加在方法前,比较时比较该方法</p>
<p>其他看源代码即可</p>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>@Data:</p>
<p>等同于之前所有的注解加在类上(用于将数据库中的数据)</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/24/Lombok-Junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/22/JAVA-JDBC%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">JAVA JDBC学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDBC就是用Java语言操作关系型数据库的一套API</p>
<p>JDBC(Java DataBase Connectivity)</p>
<p>期望用一套java代码操作不同关系型数据库</p>
<p>Sun公司提出JDB标准接口,而MySQL,ORACLE等自己实现这套接口(即MySQL驱动,ORACLE驱动,即数据库驱动jar包,面向接口编程)</p>
<p>我们可以使用这套接口编程,真正执行代码的是驱动jar包的实现类</p>
<p>步骤:</p>
<ol start="0">
<li>创建工程,导入驱动jar包</li>
</ol>
<p>mysql-connector-java-x.x.x.jar</p>
<ol>
<li>注册驱动</li>
</ol>
<pre><code class="java">Class.forName(&quot;com.mysql.jdbc.Drivaer&quot;); // 反射,将mysql的驱动类加载进内存
</code></pre>
<ol start="2">
<li>获取连接</li>
</ol>
<pre><code class="java">Connection.conn = DriverManager.getConnection(url,username,password);
</code></pre>
<ol start="3">
<li>定义SQL语句</li>
</ol>
<pre><code class="java">String sql = &quot;update...&quot;;
</code></pre>
<ol start="4">
<li>获取执行SQL对象</li>
</ol>
<pre><code class="java">Statement stmt = conn.createStatement();
</code></pre>
<ol start="5">
<li>执行SQL</li>
</ol>
<p>实际上是将sql语言发送给mysql数据库,让mysql数据库去执行</p>
<pre><code class="java">stmt.executeUpdate(sql);
</code></pre>
<ol start="6">
<li><p>处理返回结果</p>
</li>
<li><p>释放资源</p>
</li>
</ol>
<pre><code class="java">stmt.close();
conn.close();
</code></pre>
<h1 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>驱动管理类,作用</p>
<ol>
<li><p>注册驱动</p>
</li>
<li><p>获取数据库连接</p>
</li>
</ol>
<p>当使用反射把驱动加载进内存时,其类的静态代码块自动将mysql驱动注册</p>
<p>在MySQL5后,Class.forName(“com.mysql.jdbc.Driver”)可不写,因为其自动加载META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</p>
<ul>
<li>获取连接</li>
</ul>
<pre><code class="java">static Connection = getConnection(String url,String user, String password);
</code></pre>
<ol>
<li>url:连接路径</li>
</ol>
<p>语法: jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2…</p>
<p>如: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1</p>
<p>协议: jdbc:mysql</p>
<p>若连接本地mysql服务器,并且默认端口为3306,则ip地址:端口号可不写,如</p>
<p>jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称?键值对</p>
<p>配置useSSL&#x3D;false参数禁用安全连接方式,解决警告提示</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>数据库连接对象,作用:</p>
<ol>
<li><p>获取执行SQL的对象</p>
</li>
<li><p>管理事务</p>
</li>
</ol>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ol>
<li>获取执行SQL的对象</li>
</ol>
<ul>
<li>普通执行SQL对象</li>
</ul>
<pre><code class="java">Statement createStatement();
</code></pre>
<ul>
<li>预编译SQL执行SQL对象:防止SQL注入</li>
</ul>
<pre><code class="java">PreparedStatement prepareStatement(sql);
</code></pre>
<ul>
<li>执行存储过程的对象</li>
</ul>
<pre><code class="java">CallableStatement prepareCall(sql);
</code></pre>
<p>示例:</p>
<pre><code class="java">Statement stmt = createStatement();
</code></pre>
<ol start="2">
<li>事务管理</li>
</ol>
<p>JDBC事务管理: Connection接口定义了3个对应的方法</p>
<pre><code class="java">// 开启事务
setAutoCommit(boolean autoCommit); // true为自动提交事务,false手动提交
commit(); // 提交事务
rollback(); // 回滚事务, 使用try catch,如果产生异常则回滚事务
</code></pre>
<p>示例:</p>
<pre><code class="java">try&#123;
    // 开启事务
    conn.setAutoCommit(false);
    int count1 = stmt.executeUpdate(sql1);
    System.out.prinln(count1);
    int count2 = stmt.executeUpdate(sql2);
    System.out.println(count2);
    conn.commit();
&#125; catch(Exception thowables)&#123;
    conn.rollback();
    throwables.printStackTrace();
&#125;
</code></pre>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>作用: 执行SQL语句</p>
<pre><code class="sql">int executeUpdate(sql) // 执行DML,DDL语句;DML返回影响的行数,DDL执行成功也可能返回0;
ResultSet executeQuery(sql) // 执行DQL语句,返回结果集对象
</code></pre>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>作用:</p>
<p>封装了DQL查询语句的结果</p>
<p>ResultSet stmt.executeQuery(sql) : 执行SQL语句,返回ResultSet对象</p>
<p>获取查询结果:</p>
<pre><code class="java">boolean next() : 将光标向后移动一位;判断是否有效行

返回true,则有效行,有数据
xxx getXxx(参数): 获取数据

如: int getInt(参数)

参数: int 列的编号,从1开始;
String 列的名称
</code></pre>
<p>使用方法:</p>
<pre><code class="java">while(rs.next())&#123;
    // 获取数据
    int id = rs.getInt(1);
    String name = rs.getString(2);
    int money = rs.getInt(3);
&#125;

rs.close();
</code></pre>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><p>继承自Statement,预编译,防止注入</p>
<p>语法:</p>
<pre><code class="java">// 1. 获取PreparedStatement对象
// SQL语句中的参数值用?占位符替代
String sql = &quot;select * from user where user_name = ? and password = ?&quot;;

PreparedStatement pstmt = conn.prepareStatement(sql);

// 2. 设置参数值
// setXxx(?的编号,从1起,?的值)
pstmt.setString(1,name);
pstmt.setString(2,password);

// 3. 执行sql语句

executeUpdate(); // 不需要再传递sql
executeQuery();
</code></pre>
<p>解决注入原理:<br>预编译SQL,性能更高</p>
<p>对?的内容进行转义,而非单纯拼接字符串</p>
<p>MYSQL接受SQL后,首先检查SQL语法,再编译SQL为可执行函数,最后执行SQL</p>
<p>开启预编译功能:</p>
<p>useServerPreStmts &#x3D; true &#x2F;&#x2F; 预编译默认关闭,需要先开启</p>
<ol>
<li>获取PreparedStatement对象时,将sql语句发送给mysql服务器进行检查,编译(很耗时)</li>
</ol>
<p>开启方法:</p>
<pre><code class="java">String url = &quot;jdbc:mysql://localhost:3306/db1?useSSL=false&amp;useServerPreStmts=true&quot;;
</code></pre>
<ol start="2">
<li><p>执行时则不需要再进行</p>
</li>
<li><p>如果sql模板一样,则只需要一次检查编译</p>
</li>
</ol>
<p>如:</p>
<pre><code class="java">sql = &quot;select * from user where user_name = ? and password = ?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.set(1,name);
pstmt.set(2,password);
Result rs = pstmt.executeUpdate();
// 只会预编译一次,提升性能
pstmt.set(1,name);
pstmt.set(2,password);
rs = pstmt.executeUpdate();
</code></pre>
<p>配置MySQL执行日志:</p>
<pre><code class="ini">log-output=FILE
general-log=1
general_log_file = &quot;D:\mysql.log&quot;
slow-query-log = 1
slow_query_log_file=&quot;D:\mysql_slow.log&quot;
long_query_time = 2
</code></pre>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>是个容器,负责分配,管理数据库连接</p>
<p>允许应用程序重复使用一个现有的数据库连接,而非重新建立一个</p>
<p>释放空闲时间超过最大空闲时间的数据库连接防止因为没有释放数据库连接而引起数据库连接遗漏 (即如果创建了数据库连接而太长时间不用,则会自动释放)</p>
<p>好处:</p>
<p>资源重用</p>
<p>提升系统响应速度</p>
<p>避免数据库连接遗漏</p>
<p>实现:</p>
<p>标准接口: DataSource</p>
<p>SUN提供地数据库连接池标准接口,由第三方组织实现此接口</p>
<p>功能:获取连接</p>
<p>常用数据库连接池:</p>
<p>DBCP,C3P0,Druid</p>
<pre><code class="java">Connection getConnection();
</code></pre>
<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p>使用步骤:</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>定义配置文件</p>
</li>
<li><p>加载配置文件</p>
</li>
<li><p>获取数据库连接池对象</p>
</li>
<li><p>获取连接</p>
</li>
</ol>
<p>配置参数:</p>
<p>名称: druid.properties</p>
<p>driverClassName &#x3D; com.mysql.jdbc.Driver &#x2F;&#x2F; 驱动类名</p>
<p>url &#x3D; jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&amp;useServerPrepStmts&#x3D;true &#x2F;&#x2F; 启动预编译</p>
<p>username&#x3D;root</p>
<p>password&#x3D;1234</p>
<p>initialSize&#x3D;5 &#x2F;&#x2F; 初始化连接数量</p>
<p>maxActive &#x3D; 10 &#x2F;&#x2F; 最大连接数量</p>
<p>maxWait&#x3D;3000 &#x2F;&#x2F; 最大等待时间(ms)</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code class="java">// 3. 加载配置文件
Properties prop = new Properties();
prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;)); // 可能会报错,找不到路径

// 4. 获取连接池对象
DataSource dataSource =  DruidDataSourceFactory.createDataSource(prop);


// 5. 获取数据库连接
Connection conn = dataSource.getConnection();

// 找不到路径解决方案:

System.out.println(Statem.getProperty(&quot;user.dir&quot;)); // 打印用户目录,查看目前所在的路径
</code></pre>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>环境:</p>
<p>数据库表 tb_brand; 实体类 Brand </p>
<pre><code class="sql">drop table if exists tb_brand;
create table tb_brand(
    id int primary key auto_increment;
    brand_name varchar(20),
    company_name varchar(20),
    ordered int,
    description varchar(100),
    status int
);
insert into tb_brand values (...)...
</code></pre>
<p>&#x2F;&#x2F; 在pojo中,尽可能使用其包装类型,因为其默认值为null,不会对业务产生影响</p>
<pre><code class="java">// 把所有字段塞进去,塞入对应getter和setter,重写toString方法;(快捷键:Alt+Insert)
</code></pre>
<p>操作</p>
<pre><code class="java">
public class BrandTest&#123;

    @Test
    public void testSelectAll throws Exception()&#123;
        Properties prop = new Properties()
        prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;));
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);
        Connection conn=dataSource.getConnection();

        String sql = &quot;select * from tb_brand&quot;;
        PreparedStatement pstmt = conn.prepareStatement(sql);
        ResultSet rs = pstmt.executeQuery();
        while(rs.next())&#123;

            Brand a = new Brand();
            a.setId(rs.getInt(1));
            ...
        &#125;
    &#125;
&#125;
</code></pre>
<p>增删改同理</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/22/JAVA-JDBC%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/21/Maven%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">Maven学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/21/Maven%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/21/MyBatis%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">MyBatis学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MyBatis是优秀的持久层框架,用于简化JDBC开发</p>
<p>本身是Apache的开源项目iBatis</p>
<h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><ul>
<li><p>负责将数据保存到数据库的那一层代码</p>
</li>
<li><p>JavaEE三层架构: 表现层,业务层,持久层</p>
</li>
</ul>
<p>表现层: 进行页面展示</p>
<p>业务层: 处理业务逻辑</p>
<p>持久层: 将数据持久化(即存储数据)</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>框架就是半成品软件,可重用,通用,软件基础代码模型</p>
<p>框架基础上构建软件编写更有效,规范,通用,可拓展</p>
<h2 id="JDBC缺点"><a href="#JDBC缺点" class="headerlink" title="JDBC缺点"></a>JDBC缺点</h2><ol>
<li>硬编码</li>
</ol>
<p>直接将字符串写入代码内部</p>
<ol start="2">
<li>操作繁琐</li>
</ol>
<h2 id="MyBatis优化"><a href="#MyBatis优化" class="headerlink" title="MyBatis优化"></a>MyBatis优化</h2><p>将硬编码转化到配置文件中</p>
<p>操作繁琐则自动完成</p>
<p>相关持久层框架: Spring Data JPA, MyBatis-Plus…</p>
<p>术语:</p>
<p>POJO(Plain Old Java Object),普通java对象</p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>步骤:</p>
<ol>
<li><p>创建数据表,添加数据</p>
</li>
<li><p>创建项目模块,导入坐标</p>
</li>
<li><p>编写MyBatis核心配置文件,替换数据库连接信息</p>
</li>
<li><p>编写SQL映射文件,统一管理sql语句,解决硬编码问题</p>
</li>
<li><p>编码</p>
<ol>
<li>定义POLO类</li>
<li>加载核心配置文件,获取SqlSessionFactory对象</li>
<li>获取SqlSession对象,执行SQL语句</li>
<li>释放资源</li>
</ol>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/21/MyBatis%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/21/SQL%E5%AD%A6%E4%B9%A0-%E4%B9%9D-%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">
        <h2 class="post-title">SQL学习(九)视图,存储过程,触发器</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图(View)是一种虚拟存在的表,视图中的数据并不在数据库中实际存在.定义视图时的表是动态生成的,其原来的表称为基表</p>
<p>即:视图只保存了查询的SQL逻辑,不保存查询结果.(将一堆sql语句整合成一个表使用)</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>创建</li>
</ul>
<pre><code class="sql">create [or replace] view 视图名称[(列名列表)] AS SELECT语法 [WITH [CASCADED|LOCAL] CHECK OPTION];
</code></pre>
<ul>
<li>查询</li>
</ul>
<pre><code class="sql">SHOW CREATE VIEW 视图名称; -- 查询创建视图语句
SELECT * FROM 视图名称...; -- 查询视图数据
</code></pre>
<ul>
<li>修改视图</li>
</ul>
<pre><code class="sql">create [or replace] view 视图名称[(列名列表)] AS SELECT语法 [WITH [CASCADED|LOCAL] CHECK OPTION]; -- 因为有or replace
alter view 视图名称[(列名列表)] as select 语句 [WITH [CASCADED|LOCAL] CHECK OPTION];
</code></pre>
<ul>
<li>删除</li>
</ul>
<pre><code class="sql">drop view [if exists] 视图名称 [,视图名称] ...;
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create or replace view stu_v1_1 as select id,name from student where id &lt;=10;
select * from stu_v1_1 where id = 3;
create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;
alter view stu_v_1 as select id,name,no from student where id &lt;= 10;
</code></pre>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>视图可以基于另一个视图创建</p>
<p>如果直接执行insert语句,其插入到基表中,而非在视图中更新</p>
<p>向视图插入数据时,则需要满足视图的要求(仅启用视图选项时需要遵守要求)</p>
<pre><code class="sql">create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10 with cascaded check option; -- 逐级检查选项,如果此后执行insert语句,若发现与视图的字段不匹配,将阻止插入
</code></pre>
<p>可以增加检查选项cascaded check option来实时更新视图,视图选项默认为cascaded(只有增加视图选项时才可)</p>
<ul>
<li>cascaded</li>
</ul>
<p>如果不加cascaded,进行修改时不受任何影响</p>
<p>如果加上cascaded,修改时会受其影响,要求满足视图的要求</p>
<pre><code class="sql">create view v1 as select id,name from student where id &lt;= 20; -- 可以在v1插入id大于20的数据

create view v2 as select id,name from v2 where id &gt;=10 with cascaded check option; -- 会检查v1和v2的条件,只有两个条件都通过才可执行修改操作
</code></pre>
<p>如:v1无视图选项,v2基于v1,v2为cascaded,v3基于v2,无视图选项,则基表插入数据时会检查v1,v2,不会检查v3</p>
<ul>
<li>local</li>
</ul>
<p>local即只检查当前视图选项,校验过程从v2到v1,判断v1是否有选项,无则跳过,有则校验</p>
<h2 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h2><p>要使视图可更新,视图的行与基础表中行之间必须存在一对一关系.如果包含任何一项,则不可更新(即不可以向视图插入数据):</p>
<p>聚合函数(不是一对一)</p>
<p>DISTINCT(合并了)</p>
<p>GROUP BY(分组,也合并了)</p>
<p>HAVING(基于分组)</p>
<p>UNION <a href="%E5%90%88%E5%B9%B6%E8%A7%86%E5%9B%BE%E4%BA%86">ALL</a></p>
<h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol>
<li>简单</li>
</ol>
<p>视图简化用户对数据的理解,并且简化他们的操作.经常使用的操作定义为视图</p>
<ol start="2">
<li>安全</li>
</ol>
<p>数据库可以授权,但无法授权至指定行与列;通过视图用户只能查询和修改他们所看到的数据</p>
<pre><code class="sql">create user &#39;username&#39;@&#39;host&#39; identified by &#39;password&#39;;
revoke all privileges on database.table from &#39;username&#39;@&#39;host&#39;; -- 避免用户直接操作基表
grant select,insert,update,delete on database.view to &#39;username&#39;@&#39;host&#39;;
flush privileges; -- 刷新权限
</code></pre>
<ol start="3">
<li>数据独立</li>
</ol>
<p>…</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol>
<li>为保证数据库表的安全性,在操作tb_user表时,只能看到用户基本字段,屏蔽手机号和邮箱两个字段</li>
</ol>
<pre><code class="sql">create or replace view tb_user_v_1 as select id,name from tb_user local check option;
revoke all privileges on itcast.tb_user from &#39;username&#39;@&#39;host&#39;;
grant select,update,delete,insert on itcast.tb_user to &#39;username&#39;@&#39;host&#39;;
flush privileges; -- 刷新权限
</code></pre>
<ol start="2">
<li>查询每个学生所选修的课程.为简化操作定义一个视图</li>
</ol>
<pre><code class="sql">create or replace view stu_course_v_1 as select s.id,s.name,c.name from student s, course c, student_course sc where s.id = sc.stu_id and c.id = sc.course_id;
</code></pre>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程是在数据库服务器上执行各种复杂业务逻辑,而<strong>无需多次发送单个SQL查询</strong>.</p>
<p>优点:</p>
<p>性能提升:减少网络交互(最显著优点)</p>
<p>安全</p>
<p>缺点:</p>
<p>调试复杂</p>
<p>版本控制困难</p>
<p>数据库负载增加:把业务逻辑放在数据库服务器中实现,会影响数据库性能</p>
<p>现阶段存储过程一般禁用</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建</p>
<pre><code class="sql">CREATE PROCEDURE 存储过程名称[(参数列表)] -- 相当于函数定义
BEGIN
    SQL语句 -- 所有逻辑都在里面
END;
</code></pre>
<p>调用</p>
<pre><code class="sql">CALL 名称([参数])
</code></pre>
<p>查看</p>
<pre><code class="sql">SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息,xxx填数据库名称(即该数据库中有什么存储过程)
-- INFORMATION_SCHEMA系统自己的数据库,ROUTINES是该数据库自带的表

SHOW CREATE PROCEDURE 存储过程名称; -- 查看某个存储过程定义
</code></pre>
<p>删除</p>
<pre><code class="sql">DROP PROCEDURE [IF EXISTS] 存储过程名称;
</code></pre>
<p>在命令行中,执行创建存储过程的SQL中,需要通过关键字delimiter指定SQL语句的结束符(否则分号会作为存储过程的结尾)</p>
<pre><code class="sql">delimiter $$;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create procedure p1()
begin
    select count(*) from student;
end; -- 在命令行中会报错

call p1();

delimiter $$
create procedure p1()
begin
    select count(*) from student;
end$$ -- 成功执行
delimiter ; -- 恢复分隔符
</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>系统变量: 由MYSQL服务器提供,属于服务器层面;分为全局变量(GLOBAL)与会话变量(SESSION)</p>
<p>查看系统变量</p>
<pre><code class="sql">SHOW [SESSION|GLOBAL] VARIABLES; -- 查看所有系统变量
SHOW [SESSION|GLOBAL] VARIABLES LIKE &#39;...&#39;; -- 通过like可以进行模糊匹配
SELECT @@[SESSION.|GLOBAL.]系统变量名; -- 查看指定变量值
</code></pre>
<p>设置变量值</p>
<pre><code class="sql">SET [SESSION|GLOBAL] 系统变量名 = 值;
SET @@[SESSION.|GLOBAL.]系统变量名 = 值;
</code></pre>
<p>如果没有指定SESSION&#x2F;GLOBAL,默认SESSION</p>
<p>mysql重新启动后,所设置的全局参数会失效,需要在&#x2F;etc&#x2F;my.cnf中配置,则不会失效</p>
<p>示例:</p>
<pre><code class="sql">select @@session.autocommit;
set session autocommit = 0;
</code></pre>
<h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><p>用户根据需要自己定义的变量,无需提前声明,只需@变量名即可.作用域为当前连接</p>
<ul>
<li>赋值</li>
</ul>
<pre><code class="sql">SET @var_name = expr [,@var_name=expr...]; -- 因为比较相等也是用=,容易混淆
SET @var_name := expr ... ; -- 推荐使用这个
select @var_name := expr ...;
select 字段名 into @var_name FROM 表名;
</code></pre>
<ul>
<li>使用</li>
</ul>
<pre><code class="sql">SELECT @var_name;
</code></pre>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">set @myname = &#39;itcast&#39;;
set @myage := 10;
set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;

select @myname,@myage,@mygender,@myhobby;
</code></pre>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>需要DECLARE声明,范围在BEGIN … END块内</p>
<pre><code class="sql">DECLARE 变量名 变量类型 [DEFAULT ...]; -- DEFAULT 指定默认值
</code></pre>
<p>赋值:</p>
<pre><code class="sql">set 变量名:=值; -- 也可=
select field_name into 变量名 from 表名;
</code></pre>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create procedure p2()
begin
    declare stu_count int default 0;
    select count(*) into stu_count from student;
    select stu_count; 
end;

call p2();
</code></pre>
<h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><p>语法:</p>
<pre><code class="sql">IF condition1 THEN

ELSEIF condition2 THEN

ELSE
...
END IF;
</code></pre>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create procedure p4()
begin
    declare score int default 58;
    declare result varchar(10);
    if score &gt;= 85 then
        set result := &#39;优秀&#39;;
    elseif score &gt;= 60 then
        set result := &#39;及格&#39;;
    else
        set result := &#39;不及格&#39;;
    end if;
end;
</code></pre>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>in: 输入参数</p>
<p>out: 输出参数,也就是可以作为返回值</p>
<p>inout: 既可以作为输入也可以输出</p>
<p>用法:</p>
<pre><code class="sql">create procedure 存储过程名称([in/out/inout] 参数名 参数类型)
begin
    sql语句
end;
</code></pre>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p>根据传入参数score,判定等级并返回</p>
<pre><code class="sql">
create procedure p4(in score int,out result varchar(10)) -- 返回result
begin
    if score &gt;= 85 then
        set result := &#39;优秀&#39;;
    elseif score &gt;= 60 then
        set result := &#39;及格&#39;;
    else
        set result := &#39;不及格&#39;;
    else if;
end;

call p4(68,@result);


create procedure p5(inout score double)
begin
    set score := score * 0.5
end;

set @score = 50;
call p5(@score); -- 会更改@score
select @score
</code></pre>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表有关的数据库对象,即在insert&#x2F;update&#x2F;delete之前或之后触发并执行触发器中定义的SQL语句集合</p>
<p>用于数据库保证数据完整性,日志记录,数据校验等操作</p>
<p>使用OLD或NEW引用触发器中发生变化的记录内容.现触发器还只支持行级触发,不支持语句级触发</p>
<p>触发器类型:</p>
<p>INSERT型触发器:NEW表示将要或已经新增的数据</p>
<p>UPDATE型触发器:OLD表示修改之前数据,NEW表示将要或已修改的数据</p>
<p>DELETE型触发器:OLD表示将要或已经删除的数据</p>
<h2 id="insert触发器"><a href="#insert触发器" class="headerlink" title="insert触发器"></a>insert触发器</h2><p>语法:</p>
<p>创建:</p>
<pre><code class="sql">CREATE TRIGGER trigger_name
BEFORE/AFTER INSERT/UPDATE/DELETE
ON table_name FOR EACH ROW -- 行级触发器
BEGIN
    trigger_stmt;
END;
</code></pre>
<p>查看:</p>
<pre><code class="sql">SHOW TRIGGERS;
</code></pre>
<p>删除触发器:</p>
<pre><code class="sql">DROP TRIGGER [schema_name.]trigger_name; -- 如果出不指定schema_name,默认当前数据库
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #03a9f4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #00bcd4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/21/SQL%E5%AD%A6%E4%B9%A0-%E4%B9%9D-%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/20/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96/">
        <h2 class="post-title">SQL学习(八) SQL优化</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>insert优化:</p>
<ol>
<li><p>建议批量插入(一次性插入数据最好500-1000条),若上千条,则分割为多条insert插入</p>
</li>
<li><p>手动提交事务</p>
</li>
</ol>
<pre><code class="sql">start transaction;
insert ...

commit;
</code></pre>
<ol start="3">
<li>主键顺序插入</li>
</ol>
<p>建议顺序插入,而不是乱序插入</p>
<ul>
<li>大批量插入数据</li>
</ul>
<p>如果一次性插入大量数据,不建议使用insert,而是使用load</p>
<pre><code class="bash"># 客户端连接服务端时,加上参数--local-infile用于加载本地文件
mysql --local-infile -u root -p
# 设置全局参数local_infile为1,开启从本地加载文件导入数据的开关
set global local_infile = 1;
# 执行load指令,将数据文件加载至表结构中
load data local infile &#39;/root/sql1.log&#39; into table &#39;rb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;
</code></pre>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>在InnoDB存储引擎中,表数据根据主键顺序组织存放,即索引组织表(IOP,Index Organized Table)</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空,也可以填充一半,百分百.每个页包含了2-N行数据(如果一行数据过大,会行溢出),根据主键排列</p>
<p><img src="/images/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96-1.png" alt="主键顺序插入"></p>
<p>主键乱序插入时,会出现页分裂情况,具体操作如下:</p>
<p>插入一个已满的页时,将满的页分为两份,第二份放入新的页,并重新调整页与页间的指针</p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>删除一行记录时,并没有实际上被物理删除,只是被标记(flaged)为删除,并且其空间变为允许其他记录声明使用</p>
<p>当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%),InnoDB会开始寻找最靠近的页(前或后)是否可将两个页合并优化空间使用,即页合并</p>
<p>MERGE_THRESHOLD</p>
<h3 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h3><ol>
<li><p>满足业务需求情况下,尽量降低主键长度</p>
</li>
<li><p>插入数据时,尽量顺序插入(乱序插入会出现页分裂问题),选择使用AUTO_INCREMENT自增主键</p>
</li>
<li><p>尽量不要使用UUID或其他自然主键(如身份证),因为长度过长并且无序</p>
</li>
<li><p>业务操作时,尽量避免对主键的修改</p>
</li>
</ol>
<h2 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h2><p>排序方式</p>
<ol>
<li><p>Using filesort: 通过表索引或全表扫描,读取满足条件的数据行,在排序缓冲区sort buffer中完成排序操作, 所有不是通过索引直接返回排序结果的排序都称为FileSort排序</p>
</li>
<li><p>Using index: 通过索引顺序扫描直接返回有序数据,这种是using index,不需要额外排序,操作效率高</p>
</li>
</ol>
<p>即:尽可能覆盖索引,</p>
<pre><code class="sql">-- 没有创建索引时,根据age,phone进行排序(效率低)
explain select id,age,phone from tb_user order by age,phone;
-- 创建索引
create index idx_user_age_phone_aa on tb_user(age,phone);
-- 再升序排
explain select id,age,phone from tb_user order by age,phone;
-- age 降,phone降
explain select id,age,phone from tb_user order by age desc,phone desc;
-- 如果一个升序排,一个降序排,会出现FileSort
explain select id,age,name from tb_user order by age asc, phone desc;
-- 创建索引(根据升降序)
create index idx_user_phone_ad on tb_user(age asc,phone desc); -- 如果不指定asc,desc,默认asc
-- 再进行排序(此时using index)
explain select id,age,name from tb_user order by age asc,phone desc;
</code></pre>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p>根据排序字段建立合适的索引,多字段排序时,遵循最左前缀法则</p>
</li>
<li><p>尽量使用覆盖索引</p>
</li>
<li><p>多字段排序,一个升一个降时,注意联合索引在创建时的规则(ASC&#x2F;DESC)</p>
</li>
<li><p>如果不可避免出现filesort,大数据量排序时,可适当增大排序缓冲区大小sort_buffer_size(默认256k)(若超出缓冲区大小,则会在磁盘文件中排序,效率较低)</p>
</li>
</ol>
<h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><pre><code class="sql">-- 删索引
drop index idx_user_pro_age_sta on tb_user;
-- 执行分组操作,根据profession字段分组
explain select profession,count(*) from tb_user group by profession;
-- 创建索引
create index idx_user_sta on tb_user(profession,age,status)
-- 分组,根据profession字段分组
explain select profession,count(*) from tb_user group by profession; -- 满足最左前缀
-- 根据profession,age分组
explain select profession,count(*) from tb_user group by profession,age; -- 满足最左前缀
explain select profession,count(*) from tb_user group by age; -- 不满足最左前缀
explain select profession,count(*) from tb_user where profession = &#39;软件工程&#39; group by age; -- 满足最左前缀
</code></pre>
<p>当我们执行 group by 操作在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照 group by 指定的列进行排序。在这个临时表里面，对于每一个 group 的数据行来说是连续在一起的。完成排序之后，就可以发现所有的 groups，并可以执行聚集函数（aggregate function）。可以看到，在没有使用索引的时候，需要创建临时表和排序。在执行计划中通常可以看到“Using temporary; Using filesort”。</p>
<p>在Extra中</p>
<p>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</p>
<p>Using temporary，表示使用了临时表；</p>
<p>Using filesort，表示需要排序。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>满足最左前缀法则,尽可能覆盖索引,避免建立临时表</p>
<h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>在大数据情况下,越往后效率越低,耗时越长,如limit 2000000,10,此时mysql需要对前2000000进行排序,而仅返回需要的10个数据,并丢弃前面的记录,代价巨大</p>
<p>优化思路: 创建 覆盖索引 提升性能,通过覆盖索引和子查询形式进行优化</p>
<pre><code class="sql">explain select * from tb_sku t limit 2000000,10; -- 耗时时间长

select id from tb_sku order by id limit 2000000,10;
explain select * from tb_sku t, (select id from tb_sku order by id limit 2000000, 10) a where t.id = a.id;
explain select * from tb_sku where id in (select id from tb_sku order by id limit 2000000,10);
</code></pre>
<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><pre><code class="sql">explain select count(*) from tb_user;
</code></pre>
<p>MyISAM引擎把一个表总行数存在磁盘中,因此执行count(*)时直接返回该数,效率高</p>
<p>InnoDB需要一行行读出来,累积计数</p>
<p>优化思路:自己计数(自行维护总数,插入时自行加一,删除时自行减一)</p>
<h3 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h3><p>非null计数</p>
<p>count(*),count(字段),count(1)</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>count(主键)</li>
</ul>
<p>InnoDB引擎遍历整张表,把每一行主键id值取出来,返回给服务层,服务层拿到主键后一行行累加(主键不可能为null)</p>
<ul>
<li>count(字段)</li>
</ul>
<p>没有not null约束: InnoDB引擎遍历整张表把每一行字段取出来,返回给服务层,判断是否为null</p>
<p>有not null约束:同count(主键)</p>
<ul>
<li>count(1)</li>
</ul>
<p>InnoDB遍历整张表,但不取值,对于返回的每一行放个’1’进去,直接按行累加</p>
<ul>
<li>count(*)</li>
</ul>
<p>InnoDB引擎并不把全部字段取出,而是优化,不取值,直接进行累加</p>
<p>效率排行: count(字段) &lt; count(主键) &lt; count(1) &#x3D; count(*),所以尽量使用count(*)</p>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><pre><code class="sql">update student set no = &#39;200100100&#39; where id = 1;
update student set no = &#39;2000100105&#39; where name = &#39;韦一笑&#39;;
</code></pre>
<p>InnoDB行锁是针对索引加的锁,而非针对记录加的锁,并且该索引不能失效,否则将从行锁上升到表锁;如果没有索引,也会从行锁上升至表锁</p>
<p>上升至表锁,并发性能将会降低</p>
<p>加锁后,只要事务没有提交,该锁就不会释放</p>
<p>不要让锁上升至表锁,否则所有业务都会停滞</p>
<p>关键还得看这条语句在执行过程中，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ffa2c4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ff7d73">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/20/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95/">
        <h2 class="post-title">SQL学习(七) 存储引擎,索引</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MYSQL体系结构"><a href="#MYSQL体系结构" class="headerlink" title="MYSQL体系结构"></a>MYSQL体系结构</h2><p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-1.png" alt="体系结构图"></p>
<ul>
<li>客户端连接器</li>
</ul>
<p>用于连接mysql服务器</p>
<ul>
<li>连接层</li>
</ul>
<p>连接池,接收客户端连接,进行认证处理(校验密码),权限等,检查是否超过最大连接数</p>
<ul>
<li>服务层</li>
</ul>
<p>核心功能, SQL接口,解析器,查询优化器,缓存</p>
<ul>
<li>可插拔引擎层</li>
</ul>
<p>可插拔:如果需要该存储引擎,则插入;不需要则拔掉,即可插拔</p>
<p>控制数据存储和提取方式</p>
<p>索引是在存储引擎实现的,即:不同引擎索引结构不同</p>
<p>InnoDB是Mysql5.5后默认引擎</p>
<ul>
<li>存储层</li>
</ul>
<p>用于存储数据库相关数据,如日志,系统文件,数据文件</p>
<h2 id="存储引擎-1"><a href="#存储引擎-1" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎即 存储数据,更新&#x2F;查询等技术实现方式.存储引擎是基于<strong>表</strong>的,而不是基于库的,因此存储引擎也可被称为表类型</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>查询建表语句 – 默认InnoDB</p>
<pre><code class="sql">show create table 表;
</code></pre>
<p>查询当前数据库支持的存储引擎</p>
<pre><code class="sql">SHOW ENGINES;
</code></pre>
<p>创建表时,指定存储引擎:</p>
<pre><code class="sql">create table 表名(
    字段名 类型(范围) 约束 comment 注释,
    ... 
)ENGINE = 存储引擎 comment 注释;
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>创建 my_myisam, 并指定MyISAM存储引擎</p>
<pre><code class="sql">create table my_myisam(
    id int,
    name varchar(10)
)engine = MyISAM;
</code></pre>
<p>创建表my_memory,并指定Memory存储引擎</p>
<pre><code class="sql">create table my_memory(
    id int,
    name varchar(10)
)engine = Memory;
</code></pre>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>高可靠性和高性能,MySQL5.5后为默认MySQL存储引擎</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h4><p>DML操作支持ACID模型,支持<strong>事务</strong></p>
<p><strong>行级锁</strong>,提高并发访问性能</p>
<p>支持<strong>外键</strong>约束,保证数据完整和正确性</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>xxx.idb, xxx为表名,innoDB引擎每张表都会有一个idb文件,存储表结构(frm,sdi),数据和索引</p>
<p>参数:innodb_file_per_table(默认打开,说明每个表独立空间,关闭则共享空间)</p>
<p>命令行:idb2sdi,从idb文件提取表结构</p>
<h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p>TableSpace: 表空间 存储Segment</p>
<p>Segment: 段 存储Extent</p>
<p>Extent: 区 存储Page, 大小固定1M,包含64个page</p>
<p>Page: 页 存储Row,是磁盘操作的最小单元,大小固定16K</p>
<p>Row: 行 存储数据</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL早期引擎</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>不支持事务,不支持外键</p>
<p>支持表锁,不支持行锁</p>
<p>访问速度快</p>
<h4 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h4><p>xxx.sdi: 表结构信息,可直接打开,存储json文件数据</p>
<p>xxx.MYD: 存储数据</p>
<p>xxx.MYI: 存储索引</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>存储在内存中,受到硬件问题,或断电影响,这些表只能作为临时表或缓存使用</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>内存存放(快)</p>
<p>hash索引(默认)</p>
<h4 id="文件-2"><a href="#文件-2" class="headerlink" title="文件:"></a>文件:</h4><p>xxx.sdi(存储表结构,只有这个文件,因为数据都在内存中)</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-2.png" alt="三引擎区别图"></p>
<h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>InnoDB: MySQL默认存储引擎,事务外键行级锁,若应用对事务完整性有较高要求,在并发条件下要求数据一致性,数据除了插入,查询外,还有很多更新删除操作,则选用InnoDB较合适</p>
<p>MyISAM: 若应用是以读或插入为主,而很少有更新或删除操作,对事务完整性要求并不高,则选用MyISAM较合适, 如日志,或评论等 被替代品:MongoDB(nosql)</p>
<p>Memory: 所有数据在内存中,访问速度快,通常用于临时表及缓存.缺陷即对表大小有限制,无法保障数据安全性 被替代品:Redis(nosql)</p>
<h1 id="Linux安装MySQL"><a href="#Linux安装MySQL" class="headerlink" title="Linux安装MySQL"></a>Linux安装MySQL</h1><ol>
<li>准备Linux服务器</li>
</ol>
<p>版本如CentOS7</p>
<ol start="2">
<li>远程连接Linux服务器</li>
</ol>
<p>使用如Final Shell工具</p>
<ol start="3">
<li><p>下载Linux版MySQL安装包</p>
</li>
<li><p>上传至Linux系统</p>
</li>
<li><p>创建目录,解压</p>
</li>
<li><p>安装mysql安装包(注意安装顺序)</p>
</li>
<li><p>启动SQL服务</p>
</li>
</ol>
<pre><code class="bash">systemctl start mysqld
systemctl restart mysqld
systemctl stop mysqld
</code></pre>
<ol start="8">
<li>查询自动生成的root用户密码</li>
</ol>
<pre><code class="bash">grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<ol start="9">
<li>设定密码</li>
</ol>
<p>Linux下有密码校验,密码不能太简单,可以设置密码校验策略</p>
<pre><code class="sql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;1234&#39;; -- 修改root密码
</code></pre>
<pre><code class="sql">set global validate_password.policy = 0; -- 设置密码校验强度,0表最弱,1表最强
set global validate_password.length = 4; -- 设置密码长度
</code></pre>
<ol start="10">
<li>创建用户</li>
</ol>
<pre><code class="sql">create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;1234&#39;; -- 用于远程访问
</code></pre>
<ol start="11">
<li>防火墙</li>
</ol>
<p>防火墙开放相应端口,否则可能无法远程连接</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助MySQL高效获取数据的数据结构(有序),在数据之外,数据库系统维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据.这种数据结构即为索引</p>
<p>优点:</p>
<p>加快数据检索效率,降低IO成本;通过索引进行排序,降低CPU效率</p>
<p>缺点:</p>
<p>索引列占用空间(磁盘便宜);降低更新表的速度(增删改频率低)</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>B+Tree索引: 最常见所有,大部分引擎支持B+树索引</p>
<p>Hash索引: 底层数据结构由哈希表实现,只有精确匹配索引列查询时有效,不支持范围查询</p>
<p>R-tree(空间索引): MyISAM引擎的特殊索引类型,主要用于地理空间数据类型,使用较少</p>
<p>Full-text(全文索引): 通过建立倒排索引,快速匹配文档的方式,类似于Lucene,Solr,ES(将文本分词后记录每个词出现在哪篇文本中,用于文本检索)</p>
<p>B+Tree: 三者均支持</p>
<p>Hash 索引: 仅Memory支持</p>
<p>R-tree: 仅MyISAM支持</p>
<p>Full-text: InnoDB 5.6后支持,MyISAM支持</p>
<p>一般指的索引均是B+树结构组织的索引</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>二叉树弊端: 顺序插入时,会退化为链表,查询性能大大降低,大数据量情况下,层级较深,检索速度慢(需要平衡)</p>
<p>解决方案: 红黑树(解决平衡问题)</p>
<p>红黑树问题: 因为是二叉树,层级较深,检索速度慢</p>
<p>B-Tree(多路平衡查找树)</p>
<p>以最大度数5的b树为例(一个节点下四个key(自身),5个指针(指向5个子节点))</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-3.png" alt="B树图例"></p>
<p>当一个节点大于key数时,该节点中间元素向上分裂</p>
<p>B+树:</p>
<p>所有元素均会出现底层叶子节点中(上层的节点用于索引作用),下层形成单向链表,提高插入元素的效率</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-4.png" alt="B+树图例"></p>
<p>mysql进行了优化,下层为双向循环链表</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-5.png" alt="b+树mysql优化图例"></p>
<p>key值和指针的大小为一个页大小,即16K,因为B+树叶子不存储数据,能够存放的东西变多了,层级变少</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>采用一定hash算法,键值转化为新的hash值,对应到相应槽位中,存储到hash表中</p>
<p>hash冲突(hash碰撞):两个或多个值落于相同槽位上;可以通过链表解决</p>
<p>hash索引特点:</p>
<ol>
<li><p>只能用于对等匹配(&#x3D;,in), 不支持范围查询(between,&gt;,&lt;,…)</p>
</li>
<li><p>无法利用索引完成排序操作</p>
</li>
<li><p>查询效率,通常一次检索即可(不出现哈希碰撞情况下),效率通常高于B+树</p>
</li>
</ol>
<p>存储引擎支持:</p>
<p>Memory引擎支持.InnoDB具有自适应hash功能,hash索引是存储引擎根据B+树索引在指定条件下自动构建的.</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么InnoDB存储引擎使用B+tree呢?</p>
<p>相对于二叉树,层级更少,搜索效率高</p>
<p>对于B树,节点都会保存数据,导致一页中存储键值减少,指针减少.要同样保存大量数据,只能增加树的高度,导致性能降低</p>
<p>相对于哈希索引(只支持等值匹配),B+tree支持范围匹配</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建,只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列值重复</td>
<td>(创建唯一字段时自动创建)可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找文本中关键词,而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>根据索引存储形式,分为以下两种:</p>
<p>聚集索引(clustered Index): 数据存储和索引放在一块, 索引结构和叶子节点保存了行数据 必须有且只有一个</p>
<p>二级索引(Secondary Index): 将数据和索引分开存储,索引结构的叶子节点关联的是对应主键 可以存在多个</p>
<p>聚集索引选取规则:</p>
<p>如果存在主键,主键索引就是聚集索引</p>
<p>若不存在主键,将使用唯一索引作为聚集索引</p>
<p>如果表没有主键,或没有合适的唯一索引,则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-6.png" alt="聚集索引图例"></p>
<p>每个叶子节点都保存行数据</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-7.png" alt="二级索引图例"></p>
<p>二级索引每个叶子存储唯一索引</p>
<p>当执行select * from user where name &#x3D; ‘arm’时,首先从二级索引找到arm,然后通过唯一索引找到行数据,并返回</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol>
<li>效率问题</li>
</ol>
<p>select * from user where id &#x3D; 10;</p>
<p>与</p>
<p>select * from user where name &#x3D; ‘Arm’;</p>
<p>前者效率更高,因为前者只需要进行聚集索引的查找,而后者需要先通过二级索引,再通过聚集索引查找(后者称为<strong>回表查询</strong>)</p>
<ol start="2">
<li>B+树高度问题</li>
</ol>
<p>假设一行数据1k大小,一页则可以存储16个这样的数据;InnoDB指针占用6字节空间,主键设为BigInt,占用空间为8字节</p>
<p>当高度为2时,根节点一个<br>设n为主键个数,一个节点为一页大小,则</p>
<p>8<em>n+6(n+1) &#x3D; 16</em>1024</p>
<p>则n&#x3D;1170,则一个节点指针个数为1171,一个叶子节点有16个数据,则数据量为16*1171 &#x3D; 18736个</p>
<p>若树高度为3,则18736*1171 &#x3D; 21939856个数据</p>
<h2 id="索引操作语法"><a href="#索引操作语法" class="headerlink" title="索引操作语法"></a>索引操作语法</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li>创建索引</li>
</ul>
<pre><code class="sql">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...); -- 若不指定UNIQUE,FULLTEXT,则为常规索引
</code></pre>
<p>如果一个索引仅关联一个字段,则称为单列索引</p>
<p>如果一个索引关联多个字段,则成为联合索引|组合索引</p>
<ul>
<li>查看索引</li>
</ul>
<pre><code class="sql">SHOW INDEX FROM table_name;
</code></pre>
<ul>
<li>删除索引</li>
</ul>
<pre><code class="sql">DROP INDEX index_name ON table_name;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p>name字段姓名字段,该字段值可能会重复,为该字段创建索引</p>
</li>
<li><p>phone手机号字段值,非空唯一,创建唯一索引</p>
</li>
<li><p>为profession,age,status创建联合索引</p>
</li>
<li><p>为email建立合适的索引提高查询效率</p>
</li>
</ol>
<pre><code class="sql">create index idx_user_name on tb_user(name);
create unique index idx_phone on tb_user(phone);
create index idx_profession_age_status on tb_user(profession,age,status);
create index idx_email on tb_user(email);
</code></pre>
<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="查询操作次数"><a href="#查询操作次数" class="headerlink" title="查询操作次数"></a>查询操作次数</h3><ul>
<li>SQL执行频率</li>
</ul>
<p>MYSQL客户端连接成功后,通过show [session|global] status提供服务端状态信息,查看当前数据库INSERT,UPDATE,DELETE,SELECT访问频次</p>
<pre><code class="sql">show global status like &#39;com_______&#39; -- like后面表示需要查询的操作
</code></pre>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数(long_query_time,s,默认10s)的所有SQL语句的日志</p>
<p>MySQL慢查询日志默认未开启,需要在MySQL配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息:</p>
<pre><code class="bash"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志时间为2s,SQL语句执行时间超过2s,则视为慢查询,记录慢查询日志
long_query_time = 2
</code></pre>
<ul>
<li>查询变量</li>
</ul>
<pre><code class="sql">show variables like &#39;slow_query_log&#39; -- 查看慢查询日志是否开启
</code></pre>
<p>慢查询日志位置: &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost_slow.log</p>
<h3 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h3><p>show profiles能够在优化SQL时帮助了解时间消耗,通过have_profiling参数,查看系统是否支持profile操作</p>
<pre><code class="sql">SELECT @@have_profiling; -- 查看是否支持
</code></pre>
<p>默认profiling关闭,可以通过SET语句在session&#x2F;global级别开启profiling</p>
<pre><code class="sql">select @@profiling; -- 查询是否开启
SET [SESSION|GLOBAL] profiling = 1; 
show profile; -- 查看操作时所消耗的时间
</code></pre>
<ul>
<li>查询指定query_id的SQL语句各个阶段耗时情况</li>
</ul>
<pre><code class="sql">show profile for query query_id;
</code></pre>
<ul>
<li>查看指定query_id的SQL语句CPU使用情况</li>
</ul>
<pre><code class="sql">show profile cpu for query query_id;
</code></pre>
<h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>EXPLAIN或DESC命令获取MYSQL如何执行SELECT语句信息,包括SELECT语句执行过程中表如何连接和链接的顺序</p>
<pre><code class="sql">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件; -- 直接在前面加EXPLAIN/DESC即可
</code></pre>
<h4 id="各字段含义"><a href="#各字段含义" class="headerlink" title="各字段含义"></a>各字段含义</h4><ul>
<li>id</li>
</ul>
<p>select查询的序列号,表查询中执行select子句或操作表的顺序(id越大,越先执行;id相同,从上至下执行)</p>
<ul>
<li>select_type</li>
</ul>
<p>表select类型</p>
<p>SIMPLE: 简单表,即不使用表连接或子查询</p>
<p>PRIMARY: 主查询,即外层的查询</p>
<p>UNION: UNION中的第二个或后面的查询语句</p>
<p>SUBQUERY: SELECT&#x2F;WHERE之后包含了子查询</p>
<ul>
<li>type</li>
</ul>
<p>表示连接类型,性能由好到差为: NULL,system,const,eq_ref,ref,range,index,all.</p>
<p>业务系统中不太可能出现NULL(因为NULL是在不访问任何表时出现),尽量向前优化即可</p>
<p>system基本是访问系统表时出现</p>
<p>const在访问主键或唯一索引时会出现</p>
<p>ref在非唯一索引访问时会出现(回表查询)</p>
<p>index是扫描了全部索引</p>
<p>all代表全表扫描,性能最差</p>
<pre><code class="sql">select &#39;A&#39;; -- NULL
</code></pre>
<ul>
<li>possible_key</li>
</ul>
<p>显示可能应用在这张表上的索引,一个或多个</p>
<ul>
<li>key</li>
</ul>
<p>实际用到的索引,若NULL,则没有使用索引</p>
<ul>
<li>key_len</li>
</ul>
<p>表索引中使用的字节数,该值表示索引字段最大可能长度,并非实际使用长度,在不损失精确性前提下,长度越短越好;关注,用于查明是否在检索时使用了相关的索引</p>
<ul>
<li>ref</li>
</ul>
<p>哪些列或者常量被用做索引列上的值</p>
<ul>
<li>rows</li>
</ul>
<p>MySQL认为必须要执行查询的行数,在InnoDB引擎表中,是一个估计值(仅作参考)</p>
<ul>
<li>filtered</li>
</ul>
<p>表示返回结果行数占需读取行数的百分比,filtered的值越大越好(即有效的查询量)</p>
<ul>
<li>Extra</li>
</ul>
<p>附加信息</p>
<h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h3><p>未建立索引前,执行如下SQL语句,查看SQL的耗时</p>
<pre><code class="sql">SELECT * FROM table_name where name = &quot;xxx&quot;; -- 进行查询
</code></pre>
<p>针对字段创建索引</p>
<pre><code class="sql">create [UNIQUE|FULLTEXT] index idx_name on table_name(field_name);
</code></pre>
<p>再次指向相同SQL语句,查看SQL耗时</p>
<h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>针对联合索引. 要求遵循最左前缀法则</p>
<p>最左前缀法则: 查询从索引最左列开始,并且不能跳过索引中的列,<strong>在查询时必须包括最左侧的列,否则将不会走索引</strong></p>
<p>若跳过了某一列,则索引将部分失效(后面的字段索引失效)</p>
<p>即要求最左列必须存在,否则将跳过某一列(即最左列要表明右侧均存在)</p>
<p>如</p>
<pre><code class="sql">create index idx_a_b_c on test(a,b,c);
</code></pre>
<pre><code class="sql">select * from test where a = &#39;aa&#39;; -- 满足最左前缀法则,ref
select * from test where a = &#39;a&#39; and b = &#39;b&#39; and c = &#39;c&#39; ; -- 满足最左前缀法则,ref
select * from test where b = &#39;b&#39; ;-- 不满足最左前缀法则,全表扫描,索引没有生效
select * from test where a=&#39;a&#39; and c = &#39;c&#39;; -- 索引部分失效,前面满足最左前缀法则,索引生效,中间跳过了b,后面索引失效
select * from test where c = &#39;c&#39; and b = &#39;b&#39; and a = &#39;a&#39;; -- 索引生效,只需要存在即可满足最左前缀法则,不需要关注顺序
</code></pre>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>联合索引中,出现范围查询(&gt;,&lt;),范围查询右侧的列索引失效,如:</p>
<pre><code class="sql">explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status = &#39;0&#39;; -- key_len 49,说明status没有使用索引,因为范围查询右侧不走索引
explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 and status = &#39;0&#39;; -- key_len 54,说明status使用索引,因此尽可能使用&gt;=这样的运算符
</code></pre>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol>
<li>索引列运算</li>
</ol>
<p>不要在索引列上进行运算,否则索引将失效</p>
<p>如:</p>
<pre><code class="sql">select * from tb_user where substring(phone,10,2) = &#39;15&#39;; -- 在索引列上进行计算,将进行全表查询,type ALL, like &quot;%15&quot;也同样(因为第一个是%,头部模糊匹配,全表)
</code></pre>
<ol start="2">
<li>字符串不加单引号,隐式类型转换</li>
</ol>
<p>字符串字段使用时,必须要加单引号,不然索引失效(因为隐式转换相当于调用函数)</p>
<ol start="3">
<li>模糊查询</li>
</ol>
<p>若仅仅尾部模糊匹配,则索引不会失效;若头部模糊匹配,索引将会失效</p>
<p>‘%12’ 头部模糊查询失效</p>
<p>‘软件%’ 尾部查询,索引不失效</p>
<ol start="4">
<li>or连接的条件</li>
</ol>
<p>若or一侧有索引,一侧没有索引(或不满足最左前缀原则),不生效,只有两侧都有索引才生效(因为有一个没有索引,就会走全表扫描,为了高效,就不必走索引了)</p>
<p>解决方案: 对于没有索引的建立索引</p>
<ol start="5">
<li>数据分布影响</li>
</ol>
<p>如果MySQL评估发现比全表扫描还慢时,就会直接全表扫描</p>
<p>原因:若几乎所有表内数据基本符合查询条件,则直接全表扫描,不会走索引,提高效率</p>
<h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><p>在SQL语句中加入一些认为的提示来达到优化操作的目的</p>
<p>use index:</p>
<pre><code class="sql">explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL去用这个索引
</code></pre>
<p>当sql评估使用该索引速度较慢时,则不会使用该索引</p>
<p>ignore index:</p>
<pre><code class="sql">explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL不要使用该索引
</code></pre>
<p>force index:</p>
<pre><code class="sql">explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL必须使用该索引
</code></pre>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>主要针对select后的字段部分</p>
<p>尽量使用覆盖索引(查询使用索引,并需要返回的列,在该索引中已经全部能够找到),减少使用select *</p>
<p>using index condition: 查找使用了索引,但是需要回表查询(性能较低)</p>
<p>using where,using index: 查找使用索引,但需要的数据都在索引列中能够找到,不需要回表查询(性能高)</p>
<pre><code class="sql">explain select id,profession from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;;
explain select id,profession,age,status from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;; -- using where ,using index
explain select id,profession,age,status,name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;; -- using index condition
explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;;
</code></pre>
<p>思考:</p>
<p>一张表四个字段(id,username,password,status),由于数据量大,需要对以下SQL语句优化,如何优化?</p>
<pre><code class="sql">select id,username,password from tb_user where username = &#39;itcast&#39;;
</code></pre>
<p>解决方案:</p>
<p>建立联合索引,则不需要回表查询</p>
<pre><code class="sql">create index idx_username_password on tb_user(username,password);
select id,username,password from tb_user where username = &#39;itcast&#39;;
</code></pre>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串时,有时需要索引很长的字符串,会使得索引变得很大;查询时,浪费大量磁盘IO,影响查询效率.此时可以只将字符串一部分前缀建立索引,大大节约索引空间提升效率</p>
<p>语法:</p>
<pre><code class="sql">create index idx_xxx on table_name(column(n)); -- n表前缀的字符串长度
</code></pre>
<p>前缀长度:</p>
<p>可以根据索引的选择性决定</p>
<p>(选择性指不重复的索引值(基数)和数据表记录总数的比值,索引选择性越高则查询效率越高,唯一索引选择性为1,最好的索引选择性,性能也最好)</p>
<p>选择性 &#x3D; 不重复索引值 &#x2F; 总数</p>
<pre><code class="sql">select count(distinct email) / count(*) from tb_user; -- 获取选择性
select count(distinct substring(email,1,5)) / count(*) from tb_user -- 获取选取一定字串后的选择性
</code></pre>
<h3 id="单列索引与联合索引的选择"><a href="#单列索引与联合索引的选择" class="headerlink" title="单列索引与联合索引的选择"></a>单列索引与联合索引的选择</h3><p>在业务场景中,如果存在多个查询条件,若针对于查询字段建立索引时,建议建立联合索引,而非单列索引</p>
<p>多个联合查询时,MySQL优化器会评估哪个字段的索引效率更高,并选择该索引完成查询</p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ol>
<li><p>针对数据量较大,且查询比较频繁的表建立索引</p>
</li>
<li><p>针对常作为查询条件(where,order by,group by)建立索引</p>
</li>
<li><p>选择区分度高的列作为索引,尽量建立唯一索引.区分度越高,使用索引效率越高</p>
</li>
<li><p>若字符串类型,字段长度较长,建立前缀索引(通过计算选择性)</p>
</li>
<li><p>尽量选择联合索引,减少单列索引,查询时,联合索引可以覆盖单列索引,节省空间,避免回表</p>
</li>
<li><p>索引并非多多益善,索引越多,维护索引结构代价巨大,会影响增删改的效率</p>
</li>
<li><p>若索引列不能存储null时,创建表时用not null约束.当优化器知道每列是否包含NULL值时,可以更好确定哪个索引最有效用于查询</p>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #00bcd4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ff7d73">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">2</a>
    
    
    <a class="page-num" href="/page/3">3</a>
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">dancingby</div>
        <div class="description">
            <p>Description<br>dancingbyです！</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://github.com/dancingby0">github</a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://afdian.net/a/dancingby">爱发电</a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 dancingby&#39;s home
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;dancingby
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
