
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>dancingby&#39;s home</title>
    <meta name="author" content="dancingby" />
    <meta name="description" content="" />
    <meta name="keywords" content="blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>DANCINGBY&#39;S HOME</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;DANCINGBY&#39;S HOME</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>dancingby&#39;s home</h1>
                <h3>dancingbyのblogs</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/09/20/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96/">
        <h2 class="post-title">SQL学习(八) SQL优化</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>insert优化:</p>
<ol>
<li><p>建议批量插入(一次性插入数据最好500-1000条),若上千条,则分割为多条insert插入</p>
</li>
<li><p>手动提交事务</p>
</li>
</ol>
<pre><code class="sql">start transaction;
insert ...

commit;
</code></pre>
<ol start="3">
<li>主键顺序插入</li>
</ol>
<p>建议顺序插入,而不是乱序插入</p>
<ul>
<li>大批量插入数据</li>
</ul>
<p>如果一次性插入大量数据,不建议使用insert,而是使用load</p>
<pre><code class="bash"># 客户端连接服务端时,加上参数--local-infile用于加载本地文件
mysql --local-infile -u root -p
# 设置全局参数local_infile为1,开启从本地加载文件导入数据的开关
set global local_infile = 1;
# 执行load指令,将数据文件加载至表结构中
load data local infile &#39;/root/sql1.log&#39; into table &#39;rb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;
</code></pre>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>在InnoDB存储引擎中,表数据根据主键顺序组织存放,即索引组织表(IOP,Index Organized Table)</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空,也可以填充一半,百分百.每个页包含了2-N行数据(如果一行数据过大,会行溢出),根据主键排列</p>
<p><img src="/images/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96-1.png" alt="主键顺序插入"></p>
<p>主键乱序插入时,会出现页分裂情况,具体操作如下:</p>
<p>插入一个已满的页时,将满的页分为两份,第二份放入新的页,并重新调整页与页间的指针</p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>删除一行记录时,并没有实际上被物理删除,只是被标记(flaged)为删除,并且其空间变为允许其他记录声明使用</p>
<p>当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%),InnoDB会开始寻找最靠近的页(前或后)是否可将两个页合并优化空间使用,即页合并</p>
<p>MERGE_THRESHOLD</p>
<h3 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h3><ol>
<li><p>满足业务需求情况下,尽量降低主键长度</p>
</li>
<li><p>插入数据时,尽量顺序插入(乱序插入会出现页分裂问题),选择使用AUTO_INCREMENT自增主键</p>
</li>
<li><p>尽量不要使用UUID或其他自然主键(如身份证),因为长度过长并且无序</p>
</li>
<li><p>业务操作时,尽量避免对主键的修改</p>
</li>
</ol>
<h2 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h2><p>排序方式</p>
<ol>
<li><p>Using filesort: 通过表索引或全表扫描,读取满足条件的数据行,在排序缓冲区sort buffer中完成排序操作, 所有不是通过索引直接返回排序结果的排序都称为FileSort排序</p>
</li>
<li><p>Using index: 通过索引顺序扫描直接返回有序数据,这种是using index,不需要额外排序,操作效率高</p>
</li>
</ol>
<p>即:尽可能覆盖索引,</p>
<pre><code class="sql">-- 没有创建索引时,根据age,phone进行排序(效率低)
explain select id,age,phone from tb_user order by age,phone;
-- 创建索引
create index idx_user_age_phone_aa on tb_user(age,phone);
-- 再升序排
explain select id,age,phone from tb_user order by age,phone;
-- age 降,phone降
explain select id,age,phone from tb_user order by age desc,phone desc;
-- 如果一个升序排,一个降序排,会出现FileSort
explain select id,age,name from tb_user order by age asc, phone desc;
-- 创建索引(根据升降序)
create index idx_user_phone_ad on tb_user(age asc,phone desc); -- 如果不指定asc,desc,默认asc
-- 再进行排序(此时using index)
explain select id,age,name from tb_user order by age asc,phone desc;
</code></pre>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p>根据排序字段建立合适的索引,多字段排序时,遵循最左前缀法则</p>
</li>
<li><p>尽量使用覆盖索引</p>
</li>
<li><p>多字段排序,一个升一个降时,注意联合索引在创建时的规则(ASC&#x2F;DESC)</p>
</li>
<li><p>如果不可避免出现filesort,大数据量排序时,可适当增大排序缓冲区大小sort_buffer_size(默认256k)(若超出缓冲区大小,则会在磁盘文件中排序,效率较低)</p>
</li>
</ol>
<h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><pre><code class="sql">-- 删索引
drop index idx_user_pro_age_sta on tb_user;
-- 执行分组操作,根据profession字段分组
explain select profession,count(*) from tb_user group by profession;
-- 创建索引
create index idx_user_sta on tb_user(profession,age,status)
-- 分组,根据profession字段分组
explain select profession,count(*) from tb_user group by profession; -- 满足最左前缀
-- 根据profession,age分组
explain select profession,count(*) from tb_user group by profession,age; -- 满足最左前缀
explain select profession,count(*) from tb_user group by age; -- 不满足最左前缀
explain select profession,count(*) from tb_user where profession = &#39;软件工程&#39; group by age; -- 满足最左前缀
</code></pre>
<p>当我们执行 group by 操作在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照 group by 指定的列进行排序。在这个临时表里面，对于每一个 group 的数据行来说是连续在一起的。完成排序之后，就可以发现所有的 groups，并可以执行聚集函数（aggregate function）。可以看到，在没有使用索引的时候，需要创建临时表和排序。在执行计划中通常可以看到“Using temporary; Using filesort”。</p>
<p>在Extra中</p>
<p>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</p>
<p>Using temporary，表示使用了临时表；</p>
<p>Using filesort，表示需要排序。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>满足最左前缀法则,尽可能覆盖索引,避免建立临时表</p>
<h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>在大数据情况下,越往后效率越低,耗时越长,如limit 2000000,10,此时mysql需要对前2000000进行排序,而仅返回需要的10个数据,并丢弃前面的记录,代价巨大</p>
<p>优化思路: 创建 覆盖索引 提升性能,通过覆盖索引和子查询形式进行优化</p>
<pre><code class="sql">explain select * from tb_sku t limit 2000000,10; -- 耗时时间长

select id from tb_sku order by id limit 2000000,10;
explain select * from tb_sku t, (select id from tb_sku order by id limit 2000000, 10) a where t.id = a.id;
explain select * from tb_sku where id in (select id from tb_sku order by id limit 2000000,10);
</code></pre>
<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><pre><code class="sql">explain select count(*) from tb_user;
</code></pre>
<p>MyISAM引擎把一个表总行数存在磁盘中,因此执行count(*)时直接返回该数,效率高</p>
<p>InnoDB需要一行行读出来,累积计数</p>
<p>优化思路:自己计数(自行维护总数,插入时自行加一,删除时自行减一)</p>
<h3 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h3><p>非null计数</p>
<p>count(*),count(字段),count(1)</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>count(主键)</li>
</ul>
<p>InnoDB引擎遍历整张表,把每一行主键id值取出来,返回给服务层,服务层拿到主键后一行行累加(主键不可能为null)</p>
<ul>
<li>count(字段)</li>
</ul>
<p>没有not null约束: InnoDB引擎遍历整张表把每一行字段取出来,返回给服务层,判断是否为null</p>
<p>有not null约束:同count(主键)</p>
<ul>
<li>count(1)</li>
</ul>
<p>InnoDB遍历整张表,但不取值,对于返回的每一行放个’1’进去,直接按行累加</p>
<ul>
<li>count(*)</li>
</ul>
<p>InnoDB引擎并不把全部字段取出,而是优化,不取值,直接进行累加</p>
<p>效率排行: count(字段) &lt; count(主键) &lt; count(1) &#x3D; count(*),所以尽量使用count(*)</p>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><pre><code class="sql">update student set no = &#39;200100100&#39; where id = 1;
update student set no = &#39;2000100105&#39; where name = &#39;韦一笑&#39;;
</code></pre>
<p>InnoDB行锁是针对索引加的锁,而非针对记录加的锁,并且该索引不能失效,否则将从行锁上升到表锁;如果没有索引,也会从行锁上升至表锁</p>
<p>上升至表锁,并发性能将会降低</p>
<p>加锁后,只要事务没有提交,该锁就不会释放</p>
<p>不要让锁上升至表锁,否则所有业务都会停滞</p>
<p>关键还得看这条语句在执行过程中，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #00bcd4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ff7d73">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/20/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95/">
        <h2 class="post-title">SQL学习(七) 存储引擎,索引</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MYSQL体系结构"><a href="#MYSQL体系结构" class="headerlink" title="MYSQL体系结构"></a>MYSQL体系结构</h2><p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-1.png" alt="体系结构图"></p>
<ul>
<li>客户端连接器</li>
</ul>
<p>用于连接mysql服务器</p>
<ul>
<li>连接层</li>
</ul>
<p>连接池,接收客户端连接,进行认证处理(校验密码),权限等,检查是否超过最大连接数</p>
<ul>
<li>服务层</li>
</ul>
<p>核心功能, SQL接口,解析器,查询优化器,缓存</p>
<ul>
<li>可插拔引擎层</li>
</ul>
<p>可插拔:如果需要该存储引擎,则插入;不需要则拔掉,即可插拔</p>
<p>控制数据存储和提取方式</p>
<p>索引是在存储引擎实现的,即:不同引擎索引结构不同</p>
<p>InnoDB是Mysql5.5后默认引擎</p>
<ul>
<li>存储层</li>
</ul>
<p>用于存储数据库相关数据,如日志,系统文件,数据文件</p>
<h2 id="存储引擎-1"><a href="#存储引擎-1" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎即 存储数据,更新&#x2F;查询等技术实现方式.存储引擎是基于<strong>表</strong>的,而不是基于库的,因此存储引擎也可被称为表类型</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>查询建表语句 – 默认InnoDB</p>
<pre><code class="sql">show create table 表;
</code></pre>
<p>查询当前数据库支持的存储引擎</p>
<pre><code class="sql">SHOW ENGINES;
</code></pre>
<p>创建表时,指定存储引擎:</p>
<pre><code class="sql">create table 表名(
    字段名 类型(范围) 约束 comment 注释,
    ... 
)ENGINE = 存储引擎 comment 注释;
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>创建 my_myisam, 并指定MyISAM存储引擎</p>
<pre><code class="sql">create table my_myisam(
    id int,
    name varchar(10)
)engine = MyISAM;
</code></pre>
<p>创建表my_memory,并指定Memory存储引擎</p>
<pre><code class="sql">create table my_memory(
    id int,
    name varchar(10)
)engine = Memory;
</code></pre>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>高可靠性和高性能,MySQL5.5后为默认MySQL存储引擎</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h4><p>DML操作支持ACID模型,支持<strong>事务</strong></p>
<p><strong>行级锁</strong>,提高并发访问性能</p>
<p>支持<strong>外键</strong>约束,保证数据完整和正确性</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>xxx.idb, xxx为表名,innoDB引擎每张表都会有一个idb文件,存储表结构(frm,sdi),数据和索引</p>
<p>参数:innodb_file_per_table(默认打开,说明每个表独立空间,关闭则共享空间)</p>
<p>命令行:idb2sdi,从idb文件提取表结构</p>
<h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p>TableSpace: 表空间 存储Segment</p>
<p>Segment: 段 存储Extent</p>
<p>Extent: 区 存储Page, 大小固定1M,包含64个page</p>
<p>Page: 页 存储Row,是磁盘操作的最小单元,大小固定16K</p>
<p>Row: 行 存储数据</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL早期引擎</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>不支持事务,不支持外键</p>
<p>支持表锁,不支持行锁</p>
<p>访问速度快</p>
<h4 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h4><p>xxx.sdi: 表结构信息,可直接打开,存储json文件数据</p>
<p>xxx.MYD: 存储数据</p>
<p>xxx.MYI: 存储索引</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>存储在内存中,受到硬件问题,或断电影响,这些表只能作为临时表或缓存使用</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>内存存放(快)</p>
<p>hash索引(默认)</p>
<h4 id="文件-2"><a href="#文件-2" class="headerlink" title="文件:"></a>文件:</h4><p>xxx.sdi(存储表结构,只有这个文件,因为数据都在内存中)</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-2.png" alt="三引擎区别图"></p>
<h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>InnoDB: MySQL默认存储引擎,事务外键行级锁,若应用对事务完整性有较高要求,在并发条件下要求数据一致性,数据除了插入,查询外,还有很多更新删除操作,则选用InnoDB较合适</p>
<p>MyISAM: 若应用是以读或插入为主,而很少有更新或删除操作,对事务完整性要求并不高,则选用MyISAM较合适, 如日志,或评论等 被替代品:MongoDB(nosql)</p>
<p>Memory: 所有数据在内存中,访问速度快,通常用于临时表及缓存.缺陷即对表大小有限制,无法保障数据安全性 被替代品:Redis(nosql)</p>
<h1 id="Linux安装MySQL"><a href="#Linux安装MySQL" class="headerlink" title="Linux安装MySQL"></a>Linux安装MySQL</h1><ol>
<li>准备Linux服务器</li>
</ol>
<p>版本如CentOS7</p>
<ol start="2">
<li>远程连接Linux服务器</li>
</ol>
<p>使用如Final Shell工具</p>
<ol start="3">
<li><p>下载Linux版MySQL安装包</p>
</li>
<li><p>上传至Linux系统</p>
</li>
<li><p>创建目录,解压</p>
</li>
<li><p>安装mysql安装包(注意安装顺序)</p>
</li>
<li><p>启动SQL服务</p>
</li>
</ol>
<pre><code class="bash">systemctl start mysqld
systemctl restart mysqld
systemctl stop mysqld
</code></pre>
<ol start="8">
<li>查询自动生成的root用户密码</li>
</ol>
<pre><code class="bash">grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<ol start="9">
<li>设定密码</li>
</ol>
<p>Linux下有密码校验,密码不能太简单,可以设置密码校验策略</p>
<pre><code class="sql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;1234&#39;; -- 修改root密码
</code></pre>
<pre><code class="sql">set global validate_password.policy = 0; -- 设置密码校验强度,0表最弱,1表最强
set global validate_password.length = 4; -- 设置密码长度
</code></pre>
<ol start="10">
<li>创建用户</li>
</ol>
<pre><code class="sql">create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;1234&#39;; -- 用于远程访问
</code></pre>
<ol start="11">
<li>防火墙</li>
</ol>
<p>防火墙开放相应端口,否则可能无法远程连接</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助MySQL高效获取数据的数据结构(有序),在数据之外,数据库系统维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据.这种数据结构即为索引</p>
<p>优点:</p>
<p>加快数据检索效率,降低IO成本;通过索引进行排序,降低CPU效率</p>
<p>缺点:</p>
<p>索引列占用空间(磁盘便宜);降低更新表的速度(增删改频率低)</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>B+Tree索引: 最常见所有,大部分引擎支持B+树索引</p>
<p>Hash索引: 底层数据结构由哈希表实现,只有精确匹配索引列查询时有效,不支持范围查询</p>
<p>R-tree(空间索引): MyISAM引擎的特殊索引类型,主要用于地理空间数据类型,使用较少</p>
<p>Full-text(全文索引): 通过建立倒排索引,快速匹配文档的方式,类似于Lucene,Solr,ES(将文本分词后记录每个词出现在哪篇文本中,用于文本检索)</p>
<p>B+Tree: 三者均支持</p>
<p>Hash 索引: 仅Memory支持</p>
<p>R-tree: 仅MyISAM支持</p>
<p>Full-text: InnoDB 5.6后支持,MyISAM支持</p>
<p>一般指的索引均是B+树结构组织的索引</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>二叉树弊端: 顺序插入时,会退化为链表,查询性能大大降低,大数据量情况下,层级较深,检索速度慢(需要平衡)</p>
<p>解决方案: 红黑树(解决平衡问题)</p>
<p>红黑树问题: 因为是二叉树,层级较深,检索速度慢</p>
<p>B-Tree(多路平衡查找树)</p>
<p>以最大度数5的b树为例(一个节点下四个key(自身),5个指针(指向5个子节点))</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-3.png" alt="B树图例"></p>
<p>当一个节点大于key数时,该节点中间元素向上分裂</p>
<p>B+树:</p>
<p>所有元素均会出现底层叶子节点中(上层的节点用于索引作用),下层形成单向链表,提高插入元素的效率</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-4.png" alt="B+树图例"></p>
<p>mysql进行了优化,下层为双向循环链表</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-5.png" alt="b+树mysql优化图例"></p>
<p>key值和指针的大小为一个页大小,即16K,因为B+树叶子不存储数据,能够存放的东西变多了,层级变少</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>采用一定hash算法,键值转化为新的hash值,对应到相应槽位中,存储到hash表中</p>
<p>hash冲突(hash碰撞):两个或多个值落于相同槽位上;可以通过链表解决</p>
<p>hash索引特点:</p>
<ol>
<li><p>只能用于对等匹配(&#x3D;,in), 不支持范围查询(between,&gt;,&lt;,…)</p>
</li>
<li><p>无法利用索引完成排序操作</p>
</li>
<li><p>查询效率,通常一次检索即可(不出现哈希碰撞情况下),效率通常高于B+树</p>
</li>
</ol>
<p>存储引擎支持:</p>
<p>Memory引擎支持.InnoDB具有自适应hash功能,hash索引是存储引擎根据B+树索引在指定条件下自动构建的.</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么InnoDB存储引擎使用B+tree呢?</p>
<p>相对于二叉树,层级更少,搜索效率高</p>
<p>对于B树,节点都会保存数据,导致一页中存储键值减少,指针减少.要同样保存大量数据,只能增加树的高度,导致性能降低</p>
<p>相对于哈希索引(只支持等值匹配),B+tree支持范围匹配</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建,只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列值重复</td>
<td>(创建唯一字段时自动创建)可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找文本中关键词,而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>根据索引存储形式,分为以下两种:</p>
<p>聚集索引(clustered Index): 数据存储和索引放在一块, 索引结构和叶子节点保存了行数据 必须有且只有一个</p>
<p>二级索引(Secondary Index): 将数据和索引分开存储,索引结构的叶子节点关联的是对应主键 可以存在多个</p>
<p>聚集索引选取规则:</p>
<p>如果存在主键,主键索引就是聚集索引</p>
<p>若不存在主键,将使用唯一索引作为聚集索引</p>
<p>如果表没有主键,或没有合适的唯一索引,则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-6.png" alt="聚集索引图例"></p>
<p>每个叶子节点都保存行数据</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-7.png" alt="二级索引图例"></p>
<p>二级索引每个叶子存储唯一索引</p>
<p>当执行select * from user where name &#x3D; ‘arm’时,首先从二级索引找到arm,然后通过唯一索引找到行数据,并返回</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol>
<li>效率问题</li>
</ol>
<p>select * from user where id &#x3D; 10;</p>
<p>与</p>
<p>select * from user where name &#x3D; ‘Arm’;</p>
<p>前者效率更高,因为前者只需要进行聚集索引的查找,而后者需要先通过二级索引,再通过聚集索引查找(后者称为<strong>回表查询</strong>)</p>
<ol start="2">
<li>B+树高度问题</li>
</ol>
<p>假设一行数据1k大小,一页则可以存储16个这样的数据;InnoDB指针占用6字节空间,主键设为BigInt,占用空间为8字节</p>
<p>当高度为2时,根节点一个<br>设n为主键个数,一个节点为一页大小,则</p>
<p>8<em>n+6(n+1) &#x3D; 16</em>1024</p>
<p>则n&#x3D;1170,则一个节点指针个数为1171,一个叶子节点有16个数据,则数据量为16*1171 &#x3D; 18736个</p>
<p>若树高度为3,则18736*1171 &#x3D; 21939856个数据</p>
<h2 id="索引操作语法"><a href="#索引操作语法" class="headerlink" title="索引操作语法"></a>索引操作语法</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li>创建索引</li>
</ul>
<pre><code class="sql">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...); -- 若不指定UNIQUE,FULLTEXT,则为常规索引
</code></pre>
<p>如果一个索引仅关联一个字段,则称为单列索引</p>
<p>如果一个索引关联多个字段,则成为联合索引|组合索引</p>
<ul>
<li>查看索引</li>
</ul>
<pre><code class="sql">SHOW INDEX FROM table_name;
</code></pre>
<ul>
<li>删除索引</li>
</ul>
<pre><code class="sql">DROP INDEX index_name ON table_name;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p>name字段姓名字段,该字段值可能会重复,为该字段创建索引</p>
</li>
<li><p>phone手机号字段值,非空唯一,创建唯一索引</p>
</li>
<li><p>为profession,age,status创建联合索引</p>
</li>
<li><p>为email建立合适的索引提高查询效率</p>
</li>
</ol>
<pre><code class="sql">create index idx_user_name on tb_user(name);
create unique index idx_phone on tb_user(phone);
create index idx_profession_age_status on tb_user(profession,age,status);
create index idx_email on tb_user(email);
</code></pre>
<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="查询操作次数"><a href="#查询操作次数" class="headerlink" title="查询操作次数"></a>查询操作次数</h3><ul>
<li>SQL执行频率</li>
</ul>
<p>MYSQL客户端连接成功后,通过show [session|global] status提供服务端状态信息,查看当前数据库INSERT,UPDATE,DELETE,SELECT访问频次</p>
<pre><code class="sql">show global status like &#39;com_______&#39; -- like后面表示需要查询的操作
</code></pre>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数(long_query_time,s,默认10s)的所有SQL语句的日志</p>
<p>MySQL慢查询日志默认未开启,需要在MySQL配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息:</p>
<pre><code class="bash"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志时间为2s,SQL语句执行时间超过2s,则视为慢查询,记录慢查询日志
long_query_time = 2
</code></pre>
<ul>
<li>查询变量</li>
</ul>
<pre><code class="sql">show variables like &#39;slow_query_log&#39; -- 查看慢查询日志是否开启
</code></pre>
<p>慢查询日志位置: &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost_slow.log</p>
<h3 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h3><p>show profiles能够在优化SQL时帮助了解时间消耗,通过have_profiling参数,查看系统是否支持profile操作</p>
<pre><code class="sql">SELECT @@have_profiling; -- 查看是否支持
</code></pre>
<p>默认profiling关闭,可以通过SET语句在session&#x2F;global级别开启profiling</p>
<pre><code class="sql">select @@profiling; -- 查询是否开启
SET [SESSION|GLOBAL] profiling = 1; 
show profile; -- 查看操作时所消耗的时间
</code></pre>
<ul>
<li>查询指定query_id的SQL语句各个阶段耗时情况</li>
</ul>
<pre><code class="sql">show profile for query query_id;
</code></pre>
<ul>
<li>查看指定query_id的SQL语句CPU使用情况</li>
</ul>
<pre><code class="sql">show profile cpu for query query_id;
</code></pre>
<h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>EXPLAIN或DESC命令获取MYSQL如何执行SELECT语句信息,包括SELECT语句执行过程中表如何连接和链接的顺序</p>
<pre><code class="sql">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件; -- 直接在前面加EXPLAIN/DESC即可
</code></pre>
<h4 id="各字段含义"><a href="#各字段含义" class="headerlink" title="各字段含义"></a>各字段含义</h4><ul>
<li>id</li>
</ul>
<p>select查询的序列号,表查询中执行select子句或操作表的顺序(id越大,越先执行;id相同,从上至下执行)</p>
<ul>
<li>select_type</li>
</ul>
<p>表select类型</p>
<p>SIMPLE: 简单表,即不使用表连接或子查询</p>
<p>PRIMARY: 主查询,即外层的查询</p>
<p>UNION: UNION中的第二个或后面的查询语句</p>
<p>SUBQUERY: SELECT&#x2F;WHERE之后包含了子查询</p>
<ul>
<li>type</li>
</ul>
<p>表示连接类型,性能由好到差为: NULL,system,const,eq_ref,ref,range,index,all.</p>
<p>业务系统中不太可能出现NULL(因为NULL是在不访问任何表时出现),尽量向前优化即可</p>
<p>system基本是访问系统表时出现</p>
<p>const在访问主键或唯一索引时会出现</p>
<p>ref在非唯一索引访问时会出现(回表查询)</p>
<p>index是扫描了全部索引</p>
<p>all代表全表扫描,性能最差</p>
<pre><code class="sql">select &#39;A&#39;; -- NULL
</code></pre>
<ul>
<li>possible_key</li>
</ul>
<p>显示可能应用在这张表上的索引,一个或多个</p>
<ul>
<li>key</li>
</ul>
<p>实际用到的索引,若NULL,则没有使用索引</p>
<ul>
<li>key_len</li>
</ul>
<p>表索引中使用的字节数,该值表示索引字段最大可能长度,并非实际使用长度,在不损失精确性前提下,长度越短越好;关注,用于查明是否在检索时使用了相关的索引</p>
<ul>
<li>ref</li>
</ul>
<p>哪些列或者常量被用做索引列上的值</p>
<ul>
<li>rows</li>
</ul>
<p>MySQL认为必须要执行查询的行数,在InnoDB引擎表中,是一个估计值(仅作参考)</p>
<ul>
<li>filtered</li>
</ul>
<p>表示返回结果行数占需读取行数的百分比,filtered的值越大越好(即有效的查询量)</p>
<ul>
<li>Extra</li>
</ul>
<p>附加信息</p>
<h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h3><p>未建立索引前,执行如下SQL语句,查看SQL的耗时</p>
<pre><code class="sql">SELECT * FROM table_name where name = &quot;xxx&quot;; -- 进行查询
</code></pre>
<p>针对字段创建索引</p>
<pre><code class="sql">create [UNIQUE|FULLTEXT] index idx_name on table_name(field_name);
</code></pre>
<p>再次指向相同SQL语句,查看SQL耗时</p>
<h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>针对联合索引. 要求遵循最左前缀法则</p>
<p>最左前缀法则: 查询从索引最左列开始,并且不能跳过索引中的列,<strong>在查询时必须包括最左侧的列,否则将不会走索引</strong></p>
<p>若跳过了某一列,则索引将部分失效(后面的字段索引失效)</p>
<p>即要求最左列必须存在,否则将跳过某一列(即最左列要表明右侧均存在)</p>
<p>如</p>
<pre><code class="sql">create index idx_a_b_c on test(a,b,c);
</code></pre>
<pre><code class="sql">select * from test where a = &#39;aa&#39;; -- 满足最左前缀法则,ref
select * from test where a = &#39;a&#39; and b = &#39;b&#39; and c = &#39;c&#39; ; -- 满足最左前缀法则,ref
select * from test where b = &#39;b&#39; ;-- 不满足最左前缀法则,全表扫描,索引没有生效
select * from test where a=&#39;a&#39; and c = &#39;c&#39;; -- 索引部分失效,前面满足最左前缀法则,索引生效,中间跳过了b,后面索引失效
select * from test where c = &#39;c&#39; and b = &#39;b&#39; and a = &#39;a&#39;; -- 索引生效,只需要存在即可满足最左前缀法则,不需要关注顺序
</code></pre>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>联合索引中,出现范围查询(&gt;,&lt;),范围查询右侧的列索引失效,如:</p>
<pre><code class="sql">explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status = &#39;0&#39;; -- key_len 49,说明status没有使用索引,因为范围查询右侧不走索引
explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 and status = &#39;0&#39;; -- key_len 54,说明status使用索引,因此尽可能使用&gt;=这样的运算符
</code></pre>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol>
<li>索引列运算</li>
</ol>
<p>不要在索引列上进行运算,否则索引将失效</p>
<p>如:</p>
<pre><code class="sql">select * from tb_user where substring(phone,10,2) = &#39;15&#39;; -- 在索引列上进行计算,将进行全表查询,type ALL, like &quot;%15&quot;也同样(因为第一个是%,头部模糊匹配,全表)
</code></pre>
<ol start="2">
<li>字符串不加单引号,隐式类型转换</li>
</ol>
<p>字符串字段使用时,必须要加单引号,不然索引失效(因为隐式转换相当于调用函数)</p>
<ol start="3">
<li>模糊查询</li>
</ol>
<p>若仅仅尾部模糊匹配,则索引不会失效;若头部模糊匹配,索引将会失效</p>
<p>‘%12’ 头部模糊查询失效</p>
<p>‘软件%’ 尾部查询,索引不失效</p>
<ol start="4">
<li>or连接的条件</li>
</ol>
<p>若or一侧有索引,一侧没有索引(或不满足最左前缀原则),不生效,只有两侧都有索引才生效(因为有一个没有索引,就会走全表扫描,为了高效,就不必走索引了)</p>
<p>解决方案: 对于没有索引的建立索引</p>
<ol start="5">
<li>数据分布影响</li>
</ol>
<p>如果MySQL评估发现比全表扫描还慢时,就会直接全表扫描</p>
<p>原因:若几乎所有表内数据基本符合查询条件,则直接全表扫描,不会走索引,提高效率</p>
<h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><p>在SQL语句中加入一些认为的提示来达到优化操作的目的</p>
<p>use index:</p>
<pre><code class="sql">explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL去用这个索引
</code></pre>
<p>当sql评估使用该索引速度较慢时,则不会使用该索引</p>
<p>ignore index:</p>
<pre><code class="sql">explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL不要使用该索引
</code></pre>
<p>force index:</p>
<pre><code class="sql">explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL必须使用该索引
</code></pre>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>主要针对select后的字段部分</p>
<p>尽量使用覆盖索引(查询使用索引,并需要返回的列,在该索引中已经全部能够找到),减少使用select *</p>
<p>using index condition: 查找使用了索引,但是需要回表查询(性能较低)</p>
<p>using where,using index: 查找使用索引,但需要的数据都在索引列中能够找到,不需要回表查询(性能高)</p>
<pre><code class="sql">explain select id,profession from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;;
explain select id,profession,age,status from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;; -- using where ,using index
explain select id,profession,age,status,name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;; -- using index condition
explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;;
</code></pre>
<p>思考:</p>
<p>一张表四个字段(id,username,password,status),由于数据量大,需要对以下SQL语句优化,如何优化?</p>
<pre><code class="sql">select id,username,password from tb_user where username = &#39;itcast&#39;;
</code></pre>
<p>解决方案:</p>
<p>建立联合索引,则不需要回表查询</p>
<pre><code class="sql">create index idx_username_password on tb_user(username,password);
select id,username,password from tb_user where username = &#39;itcast&#39;;
</code></pre>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串时,有时需要索引很长的字符串,会使得索引变得很大;查询时,浪费大量磁盘IO,影响查询效率.此时可以只将字符串一部分前缀建立索引,大大节约索引空间提升效率</p>
<p>语法:</p>
<pre><code class="sql">create index idx_xxx on table_name(column(n)); -- n表前缀的字符串长度
</code></pre>
<p>前缀长度:</p>
<p>可以根据索引的选择性决定</p>
<p>(选择性指不重复的索引值(基数)和数据表记录总数的比值,索引选择性越高则查询效率越高,唯一索引选择性为1,最好的索引选择性,性能也最好)</p>
<p>选择性 &#x3D; 不重复索引值 &#x2F; 总数</p>
<pre><code class="sql">select count(distinct email) / count(*) from tb_user; -- 获取选择性
select count(distinct substring(email,1,5)) / count(*) from tb_user -- 获取选取一定字串后的选择性
</code></pre>
<h3 id="单列索引与联合索引的选择"><a href="#单列索引与联合索引的选择" class="headerlink" title="单列索引与联合索引的选择"></a>单列索引与联合索引的选择</h3><p>在业务场景中,如果存在多个查询条件,若针对于查询字段建立索引时,建议建立联合索引,而非单列索引</p>
<p>多个联合查询时,MySQL优化器会评估哪个字段的索引效率更高,并选择该索引完成查询</p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ol>
<li><p>针对数据量较大,且查询比较频繁的表建立索引</p>
</li>
<li><p>针对常作为查询条件(where,order by,group by)建立索引</p>
</li>
<li><p>选择区分度高的列作为索引,尽量建立唯一索引.区分度越高,使用索引效率越高</p>
</li>
<li><p>若字符串类型,字段长度较长,建立前缀索引(通过计算选择性)</p>
</li>
<li><p>尽量选择联合索引,减少单列索引,查询时,联合索引可以覆盖单列索引,节省空间,避免回表</p>
</li>
<li><p>索引并非多多益善,索引越多,维护索引结构代价巨大,会影响增删改的效率</p>
</li>
<li><p>若索引列不能存储null时,创建表时用not null约束.当优化器知道每列是否包含NULL值时,可以更好确定哪个索引最有效用于查询</p>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #03a9f4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #00bcd4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AD-%E4%BA%8B%E5%8A%A1/">
        <h2 class="post-title">SQL学习(六) 事务</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一组操作的集合,不可分割.事务会将一组操作作为整体进行向系统提交或撤销请求.</p>
<p>这些操作同时成功,或同时失败</p>
<p>默认MYSQL的事务是自动提交的,当每执行一条DML语句,便隐式地提交事务</p>
<p>每一个sql语句都是事务</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>操作方式:</p>
<p>将事务提交改为手动提交,在完成一些操作后,如果正常运行,则进行commit提交,如果出错,进行回滚操作</p>
<ul>
<li>查看&#x2F;设置事务提交方式:</li>
</ul>
<pre><code class="sql">SELECT @@autocommit;
SET @@autocommit = 0;
</code></pre>
<ul>
<li>提交事务</li>
</ul>
<pre><code class="sql">COMMIT;
</code></pre>
<ul>
<li>回滚事务</li>
</ul>
<pre><code class="sql">ROLLBACK;
</code></pre>
<ul>
<li>开启事务</li>
</ul>
<pre><code class="sql">START TRANSACTION 或 BEGIN;
</code></pre>
<ul>
<li>提交事务</li>
</ul>
<pre><code class="sql">COMMIT
</code></pre>
<ul>
<li>回滚事务</li>
</ul>
<pre><code class="sql">ROLLBACK;
</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>完成转账操作:张三给李四转1000(自动提交事务)</p>
<pre><code class="sql">select * from account where name = &#39;张三&#39;;
update account set money = money - 1 where name = &#39;张三&#39;;
update account set money = money + 1 where name = &#39;李四&#39;;
</code></pre>
<p>手动提交事务(方式一)</p>
<pre><code class="sql">set @autocommit = 0; -- 设置为手动提交
select * from account where name = &#39;张三&#39;;
update account set money = money - 1 where name = &#39;张三&#39;;
update account set money = money + 1 where name = &#39;李四&#39;;
-- 此时数据并未更新
commit; -- 提交事务,如果途中出错,则不会允许到commit,也就不会执行出错前的结果.

rollback; -- 回滚事务,把之前操作取消了(因为如果出错的话,则原来的操作结果会在缓存内,如果不进行回滚,当执行其他语句时,这些缓存的操作结果会影响数据,因此必须回滚)
</code></pre>
<p>方式二</p>
<pre><code class="sql">set @@autocommit = 1
start transaction;
select * from account where name = &#39;张三&#39;;
update account set money = money - 1 where name = &#39;张三&#39;;
update account set money = money + 1 where name = &#39;李四&#39;;

commit; -- 如果没有异常
rollback; -- 如果出现异常
</code></pre>
<h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ul>
<li><p>原子性(Atomicity): 事务不可分割最小单元, 要么全部成功,要么全部失败</p>
</li>
<li><p>一致性(Consistency): 事务完成时,必须使所有数据保持一致状态</p>
</li>
<li><p>隔离性(Isolation): 数据库提供隔离机制,保证事务不受外部并发操作影响</p>
</li>
<li><p>持久性(Durability): 事务一旦提交或回滚,则它对数据库数据改变是永久的</p>
</li>
</ul>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>问题如下:</p>
<ol>
<li><p>脏读: 一个事务读到另一个事务还没有提交的数据(如果那个事务失败了,则会出现问题)</p>
</li>
<li><p>不可重复读: 一个事务先后读取同一条记录,但两次读取数据不同(数据在两次读取期间被改了)</p>
</li>
<li><p>幻读: 一个事务按照条件查询数据时,没有对应数据行,但插入数据时,又发现这条数据已经存在,好像出现幻影(即查询时数据未存在,而到插入数据之前,数据被插入到表中)</p>
</li>
</ol>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>√ 表示会出现问题</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted()</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>x</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>x</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>从上至下性能下降</p>
<pre><code class="sql">-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION; 
-- 设置事务隔离级别(SESSION表当前会话,即当前客户端窗口,GLOBAL全局)
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE];
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ff7d73">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ffa2c4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AD-%E4%BA%8B%E5%8A%A1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/17/SQL%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">
        <h2 class="post-title">SQL学习(五) 多表查询</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/17
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>属于data query language</p>
<h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p>多个表关系:</p>
<p>一对多(多对一)</p>
<p>多对多</p>
<p>一对一</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例:部门与员工关系</p>
<p>关系:一:部门 多:员工</p>
<p>实现:多的一方建立外键,指向一的一方</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例:学生与课程关系</p>
<p>关系: 多:学生 多:课程</p>
<p>实现:</p>
<p>建立一张中间表,至少包含两个外键,分别关联两方主键</p>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例: 用户与用户详情的关系</p>
<p>关系: 一对一关系,多用于单表拆分,将基础字段放在一张表中,详情字段放在另一张中,以提升操作效率</p>
<p>实现:</p>
<p>在任意一方加入外键,关联另一方主键,设置外键为唯一的(UNIQUE)</p>
<p>多表查询:</p>
<p>从多表中查询数据</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h4><ul>
<li>连接查询<ul>
<li>内连接:查询A,B交集部分数据</li>
<li>外连接:<ul>
<li>左外连接: 查询左表所有数据,以及两表交集</li>
<li>右外连接: 查询右表所有数据,以及交集</li>
</ul>
</li>
<li>自连接: 当前表与自身连接查询,子链接必须使用表别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>设有emp表10个数据,dept表5个数据</p>
<pre><code class="sql">select * from emp,dept; -- 多表查询,会得到10*5=50条数据,每一个对应进行穷举得到,即笛卡尔积,即A集合与B集合所有组合情况

select * from emp,dept where emp.dept_id = dept.id;
</code></pre>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询交集部分</p>
<p>隐式内连接</p>
<pre><code class="sql">SELECT 字段列表 FROM 表1,表2 WHERE 条件;
</code></pre>
<p>显式内连接</p>
<pre><code class="sql">SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询每一个员工姓名以及关联部门名称</li>
</ol>
<pre><code class="sql">select emp.name,dept.name from emp,dept where emp.dept_id = dept.id;-- 隐式内连接
select e.name,d.name from emp e,dept d where e.dept_id = d.id; -- 如果为表起了别名,则不可以使用原名

select emp.name,dept.name from emp e inner join dept d on e.dept_id = d.id; -- 显式外连接
</code></pre>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>包含一张表所有内容以及交集部分</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT field_list FROM table1 LEFT [OUTER] JOIN table2 ON condition...; -- 左外连接

SELECT field_list FROM table1 RIGHT [OUTER] JOIN table2 ON condition...; -- 右外连接
</code></pre>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>查询emp表所有数据和相对应部门信息</p>
<pre><code class="sql">select e.*, d.name from emp e left outer join dept d on e.dept = d.id; -- 左外查询(包含未分配部门的信息)

select e.*,d.name from emp e right outer join dept d on e.dept = d.id; -- 右外查询(包含未分配员工的部门的信息)
</code></pre>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT field_list FROM tableA aliasA [INNER] JOIN tableA aliasB ON condition;

SELECT field_list FROM tableA aliasA,tableA aliasB WHERE condition;
SELECT field_list FROM tableA aliasA RIGHT|LEFT [OUTER] JOIN tableA aliasB ON condition...
</code></pre>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>自连接既可以使用内连接,也可以使用外连接</p>
<p>自连接时,把一张表看作是两张表</p>
<p>如果查询内容出现null值,则需要使用外连接</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询员工及其编号所属领导名字</li>
</ol>
<pre><code class="sql">select e.name,m.name from emp e inner join emp m on e.manager_id = m.id;
</code></pre>
<ol start="2">
<li>查询所有员工信息及其领导名字emp,若员工没有领导,也需要查询</li>
</ol>
<p>需要外连接</p>
<pre><code class="sql">select e.name &#39;员工&#39;,m.name &#39;领导&#39; from emp e left outer join emp m on e.manager_id = m.id;
</code></pre>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>即把多次查询结果合并起来,形成一个新的查询结果</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT field_list FROM tableA ... -- 没有分号!
UNION [ALL]
SELECT field_list FROM tableB...; -- 这三行是一个语句!
</code></pre>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>union all: 直接将查询结果合并(会出现重复)</p>
<p>union: 去重</p>
<p>使用条件: 联合查询多张表的列数必须一致,字段类型也必须一致</p>
<p>如:</p>
<pre><code class="sql">select * from emp where salary &gt; 1
union
select name from emp where age &lt; 50; -- ERROR!字段不一致!
</code></pre>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>将薪资低于5000的员工,和年龄大于50的员工查询出来(或逻辑)</p>
<pre><code class="sql">select * from emp where salary &lt; 5000
union all
select * from emp where age &gt;50;
</code></pre>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL 语句中嵌套SELECT语句,又称嵌套查询</p>
<p>分类:</p>
<ul>
<li>标量子查询 子查询结果为单个值</li>
<li>列子查询 结果一个列</li>
<li>行子查询 一个行</li>
<li>表子查询 多行多列</li>
</ul>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</code></pre>
<p>外部语句可以是 INSERT|UPDATE|DELETE|SELECT, DQL,DML</p>
<p>位置可以是WHERE|FROM|SELECT</p>
<p>标量子查询: 常用&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D;</p>
<p>列子查询:常用 IN(在指定集合内) NOT IN ANY(子查询返回的列表中,任意一个满足即可) SOME(同ANY) ALL(必须全部满足)</p>
<p>行子查询: 常用&#x3D; !&#x3D; IN NOT IN</p>
<p>表子查询: 常用IN</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><ul>
<li>标量子查询</li>
</ul>
<p>查询销售部所有员工信息</p>
<pre><code class="sql">select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);
</code></pre>
<p>查询”方东白”入职后员工信息</p>
<pre><code class="sql">select * from emp where entry_date &gt; (select entry_date from emp where name = &#39;方东白&#39;);
</code></pre>
<ul>
<li>列子查询</li>
</ul>
<ol>
<li>查询”销售部”和”市场部”的所有员工信息</li>
</ol>
<pre><code class="sql">select * from emp where dept in (select id from dept where name in (&#39;销售部&#39;,&#39;市场部&#39;));
</code></pre>
<ol start="2">
<li>查询比财务部所有人工资都高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp where salary &gt; all(select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;)) -- where比聚合函数先执行
</code></pre>
<ol start="3">
<li>查询比研发部任意一人工资都高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp where salary &gt; any(select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;));
</code></pre>
<ul>
<li>行子查询</li>
</ul>
<p>查询与”张无忌”的薪资及其直属领导 相同的员工信息</p>
<pre><code class="sql">select * from emp where salary = (select salary from emp where name = &#39;张无忌&#39;) and manager_id = (select id from emp where name = &#39;张无忌&#39;);

select * from emp where (salary,manager_id) = (select salary,id from emp where name = &#39;张无忌&#39;);
</code></pre>
<ul>
<li>表子查询</li>
</ul>
<ol>
<li>查询与”a”,”b”的职位与薪资相同的员工信息</li>
</ol>
<pre><code class="sql">select * from emp where (dept_id,salary) in (select dept_id,salary from emp where name in(&#39;a&#39;,&#39;b&#39;));
</code></pre>
<ol start="2">
<li>查询入职日期为’2006-01-01’之后员工信息及其部门信息</li>
</ol>
<pre><code class="sql">select e.*,d.* from (select * from emp where entry_date &gt; &#39;2006-01-01&#39;) e left join dept d on d.id = e.dept_id; -- select后也可以直接写*
</code></pre>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol>
<li>查询员工姓名,年龄,职位,部门信息(隐式内连接)</li>
</ol>
<pre><code class="sql">select e.name,e.age,e.position,d.name from emp e, dept d where d.id = e.dept_id;
</code></pre>
<ol start="2">
<li>查询年龄小于30岁员工姓名,年龄,职位,部门信息(显式内连接)</li>
</ol>
<pre><code class="sql">select e.name,e.age,e.position,d.name from emp e inner join dept d where e.age&lt;30 on e.dept_id = d.id; 
</code></pre>
<ol start="3">
<li>查询拥有员工的部门(id,名称)</li>
</ol>
<pre><code class="sql">select distinct d.* from emp e join dept d on e.dept_id = d.id;
</code></pre>
<ol start="4">
<li>查询所有年龄大于40岁的员工,及其归属部门名称,如果员工没有分配部门,也需要展示</li>
</ol>
<pre><code class="sql">select e.*,d.name from emp e left join dept d on e.dept_id = d.id where e.age&gt;40;
</code></pre>
<ol start="5">
<li>查询所有员工工资等级</li>
</ol>
<p>设有sal_grade表,有losal和hisal(分别是最低工资与最高工资)两列,有grade表示薪资水平</p>
<pre><code class="sql">select e.name,s.grade from emp e, salary s where e.salary between s.losal and s.hisal;
</code></pre>
<ol start="6">
<li>查询 “研发部” 所有员工信息及工资等级</li>
</ol>
<pre><code class="sql">select e.*,s.grade from emp e,salary s where e.dept_id = (select id from dept where name = &#39;研发部&#39;) and e.salary between s.losal and s.hisal;
</code></pre>
<ol start="7">
<li>查询 “研发部” 平均工资</li>
</ol>
<pre><code class="sql">select avg(e.salary) from emp e where e.dept_id = (select id from dept where name = &#39;研发部&#39;);

select avg(e.salary) from emp e,dept,d where e.dept_id = d.id and d.name = &#39;研发部&#39;;
</code></pre>
<ol start="8">
<li>查询工资比 ‘a’ 高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp e where e.salary &gt; (select salary from emp where name = &#39;a&#39;);
</code></pre>
<ol start="9">
<li>查询比平均薪资高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp e where e.salary &gt; (select avg(salary) from emp);
</code></pre>
<ol start="10">
<li>查询比本部门平均薪资低的员工信息</li>
</ol>
<pre><code class="sql">select * from emp e1 where e1.salary &lt;(select avg(salary) from emp e2 where e1.dept_id = e2.dept_id);
</code></pre>
<ol start="11">
<li>查询所有部门信息并统计部门的员工人数</li>
</ol>
<pre><code class="sql">select d.*,(select count(*) from emp e where e.dept_id = d.id) &#39;人数&#39; from dept d;
</code></pre>
<ol start="12">
<li>查询所有学生选课情况,显示出学生名称,学号,课程名称</li>
</ol>
<p>表: student, course, student_course</p>
<p>连接条件: student.id &#x3D; student_course.student_id, course.id &#x3D; student_course.course_id</p>
<pre><code class="sql">select s.name,s.number,c.name from student s, student_course sc , course c where sc.student_id = s.id and sc.course_id = course.id;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ff7d73">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #00a596">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/17/SQL%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/16/SQL%E5%AD%A6%E4%B9%A0-%E5%9B%9B/">
        <h2 class="post-title">SQL学习(四)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>作用于字段上的规则,限制存储于表中的数据</p>
<pre><code class="sql">NOT NULL -- 非空约束
UNIQUE -- 唯一约束 所有数据均唯一
PRIMARY KEY -- 主键约束 主键是一行数据的唯一标识,非空且唯一
DEFAULT -- 默认约束,如果保存数据时,未指定该字段的值,则采用默认值
CHECK -- 检查约束,8.0.16版本后,保证字段满足某条件
FOREIGN KEY -- 外键约束, 让两张表建立起连接,保证数据一致性
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>需求:<br>id ID唯一标识 name 非空唯一 age 大于0且小于120 status 若不指定,默认1 gender 无</p>
<pre><code class="sql">create table user(
    id int primary key auto_increment comment &#39;主键&#39;, -- auto_increment 自动增长
    name varchar(10) unique not null comment &#39;姓名&#39;,
    age tinyint check (age&gt;0 and age&lt;120) comment &#39;年龄&#39;,
    status char(1) default &#39;1&#39; comment &#39;状态&#39;,
    gender char(1)
)comment &#39;用户表&#39;;

insert into user(name,age,status,gender) values (&#39;Tom&#39;,10,&#39;2&#39;,&#39;男&#39;);
insert into user(name,age,status,gender) values (&#39;Tom&#39;,10,null,&#39;男&#39;);
</code></pre>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>具有外键的称为子表(从表),外键被关联的称为父表(主表)</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">-- 添加外键
CREATE TABLE 表名(
    field_name type,
    ...
    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)
)
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名) [ON UPDATE/DELETE 外键约束];

-- 删除外键
ALTER TABLE 表名 DROP FOREIGN KEY 外键字段名;
</code></pre>
<p>外键约束:</p>
<p>NO ACTION 当父表中更新&#x2F;删除时,首先检查是否有外键关联.有则不允许,同RESTRICT</p>
<p>RESTRICT 当父表中更新&#x2F;删除时,首先检查是否有外键关联.有则不允许,同NO ACTION</p>
<p>CASCADE 当删除&#x2F;更新对应记录时,若有对应外键,则也删除&#x2F;更新对应记录(cascade 级联的,逐级的)</p>
<p>SET NULL 当删除对应记录时,若有对应外键,设为NULL(要求该外键允许取NULL)</p>
<p>SET DEFAULT 父表变更时,子表将外键设置为默认值(Innodb不支持)</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果被外键关联,则父表中不可直接删除关联字段,除非解除关联</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">-- 数据准备
create table debt(
    id int auto_increment comment &#39;ID&#39; primary key,
    name varchar(50) not null comment &#39;部门名称&#39;
)comment &#39;部门表&#39;;

insert into dept (id,name) values(1,&#39;研发部&#39;),(2,&#39;市场部&#39;),(3,&#39;财务部&#39;),(4,&#39;销售部&#39;),(5,&#39;总经办&#39;);

create table emp(
    id int auto_increment comment &#39;ID&#39; primary key,
    name varchar(10) not null comment &#39;姓名&#39;,
    job varchar(20) comment &#39;职位&#39;,
    dept_id int comment &#39;部门ID&#39;
)comment &#39;员工表&#39;;

-- 添加外键
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) reference dept(id) on update cascade on delete no action; -- 为本来的字段添加外键
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #00a596">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ffa2c4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/16/SQL%E5%AD%A6%E4%B9%A0-%E5%9B%9B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/15/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%89/">
        <h2 class="post-title">SQL学习(三)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h2><p>DCL, Data Control Language,用于管理数据库用户,访问权限</p>
<h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol>
<li>查询用户</li>
</ol>
<pre><code class="sql">USE mysql; -- 系统数据库
SELECT * FROM user; -- 用户表
</code></pre>
<ol start="2">
<li>创建用户</li>
</ol>
<pre><code class="sql">CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
</code></pre>
<ol start="3">
<li>修改用户密码</li>
</ol>
<pre><code class="sql">ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;
</code></pre>
<ol start="4">
<li>删除用户</li>
</ol>
<pre><code class="sql">DROP USER &#39;用户名&#39;@&#39;主机名&#39;;
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>创建用户itcast,只能在当前主机localhost访问,密码123456</p>
<pre><code class="sql">use mysql;
select * from user;
create user &#39;itcast&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;
</code></pre>
<p>创建用户heima,可在任意主机上访问数据库,密码123456</p>
<pre><code class="sql">use mysql;
select * from user;
create user &#39;heima&#39;@&#39;%&#39; identified by &#39;123456&#39;;
</code></pre>
<p>修改用户heima的访问密码为1234</p>
<pre><code class="sql">use mysql;
select * from user;
alter user &#39;heima&#39;@&#39;%&#39; identified with mysql_native_password &#39;1234&#39;;
</code></pre>
<p>删除itcast的localhost主机用户</p>
<pre><code class="sql">use mysql;
select * from user;
drop user &#39;itcast&#39;@&#39;localhost&#39;;
</code></pre>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>ALL,ALL PRIVILEGES 所有权限</p>
<p>SELECT 查</p>
<p>INSERT 插</p>
<p>UPDATE 修改数据</p>
<p>DELETE 删</p>
<p>ALTER 修改表</p>
<p>DROP 删库,表,视图</p>
<p>CREATE 创</p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><ol>
<li>查询权限</li>
</ol>
<pre><code class="sql">SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;
</code></pre>
<ol start="2">
<li>授予权限</li>
</ol>
<pre><code class="sql">GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;
</code></pre>
<ol start="3">
<li>撤销权限</li>
</ol>
<pre><code class="sql">REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;
</code></pre>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>多个权限用逗号隔开</p>
<p>数据库名,表名可以用*表示</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">GRANT SELECT ON itcast.* TO &#39;heima&#39;@&#39;%&#39;;
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><pre><code class="sql">CONCAT(s1,s2..) -- 拼接字符串
LOWER(str) -- 将str中全部转为小写
UPPER(str) -- 将str中全部转为大写
LPAD(str,n,pad) -- 左填充,用字符串pad对str左侧进行填充,直到达到n字符串长度
RPAD(str,n,pad) -- 右填充
TRIM(str) -- 去掉字符串头尾空格
SUBSTRING(str,start,len) -- 返回从start起len长度的字符串,注意!索引从1开始!
</code></pre>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ol>
<li>企业员工工号统一为5位数,不是五位数的前面补0</li>
</ol>
<pre><code class="sql">update emp set work_number = LPAD(work_number,5,&#39;0&#39;);
</code></pre>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><pre><code class="sql">SEIL(x) -- 向上取整
FLOOR(x) -- 向下取整
MOD(x,y) -- 返回x/y的模
RAND() -- 返回0-1的随机数
ROUND(x,y) -- 求参数x的四舍五入值,保留y位小数
</code></pre>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>生成六位数的随机验证码</p>
<pre><code class="sql">select LPAD(round(rand()*1000000,0),6,0); -- 若不足六位,补0
</code></pre>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><pre><code class="sql">CURDATE() -- 当前日期,current date
CURTIME() -- 当前时间
NOW() -- 当前日期时间
YEAR(date) -- 获取指定date年
MONTH(date)
DAY(date)
DATE_ADD(date,INTERVAL expr type) -- 返回一个日期/时间 加上时间间隔expr后的时间值
DATEDIFF(date1,date2) -- 返回date1-date2的天数
</code></pre>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>date_add</p>
<pre><code class="sql">select date_add(now(),INTERVAL 70 day); -- 第二个参数写法固定为 interval value 类型
select date_add(now(),interval 70 year);
</code></pre>
<p>datediff</p>
<pre><code class="sql">select datediff(&#39;2012-01-01&#39;,&#39;2021-10-01&#39;);
</code></pre>
<p>查询所有员工入职天数,并倒序排序</p>
<pre><code class="sql">select name,datediff(CURDATE(),entry_date) &#39;entry_days&#39; from emp order by entry_days desc; -- 别名的字符串可以省略,后面order by则不能加引号
</code></pre>
<h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><p>实现条件筛选</p>
<pre><code class="sql">IF(condition,t,f) -- 如果condition为true,则返回t,否则f
IFNULL(value1,value2) -- 如果value1为空,则返回value2,否则返回value1
CASE WHEN [val1] THEN [res1] ... ELSE [default] END -- 如果val1为true,返回res1,... 否则返回default默认值
CASE [expr] WHEN [val1] THEN [res1],... ELSE[default] END -- 如果expr的值与val1相等,返回res1,..否则返回default
</code></pre>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p>查询emp表姓名和工作地址(北京,上海)一线,其他二线</p>
<pre><code class="sql">select name,case when address in(&#39;北京&#39;,&#39;上海&#39;) THEN &#39;一线&#39; ELSE &#39;二线&#39; &#39;工作地址&#39; from emp;
select name, case address when &#39;北京&#39; then &#39;一线&#39; when &#39;上海&#39; then &#39;一线&#39; else &#39;二线&#39; as &#39;工作地址&#39; from emp;
</code></pre>
<p>统计各个学员成绩,</p>
<p>&gt;&#x3D;85 优秀</p>
<p>&gt;&#x3D;60 及格</p>
<p>否则不及格</p>
<pre><code class="sql">select name,case when score &gt;= 85 then &#39;优秀&#39; when score &gt;= 60 then &#39;及格&#39; else &#39;不及格&#39; from emp
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ffa2c4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #03a9f4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/15/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%89/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/14/sql%E5%AD%A6%E4%B9%A0-%E4%BA%8C/">
        <h2 class="post-title">sql学习(二)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/14
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h2><p>Data Manipulation Language(数据操作语言) 用于对表的数据记录进行增删改操作</p>
<p>添加数据(INSERT)</p>
<p>修改数据(UPDATE)</p>
<p>删除数据(DELETE)</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol>
<li>给字段添加数据</li>
</ol>
<pre><code class="sql">INSERT INTO 表名 (字段名1,字段名2,...) VALUES (值1,值2,...);
</code></pre>
<ol start="2">
<li>给所有字段添加数据</li>
</ol>
<pre><code class="sql">INSERT INTO 表名 VALUES (值1,值2,...);
</code></pre>
<ol start="3">
<li>批量添加数据</li>
</ol>
<pre><code class="sql">INSERT INTO 表名 (字段名1,字段名2,...) VALUES (值1,值2,...),(值1,值2,...);
INSERT INTO 表名 VALUES (值1,值2,...),(值1,值2,...); -- 不指定字段名时,对所有字段插入
</code></pre>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>insert时,插入字段名与值一一对应<br>字符串,日期应当包含在引号中<br>插入数据大小需要在字段的指定范围内</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">insert into employee(id,workno,name,gender,age,idcard,entrydata) values (1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789&#39;,&#39;2000-01-01&#39;);
insert into employee values (1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789&#39;,&#39;2000-01-01&#39;);
insert into employee values (1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789&#39;,&#39;2000-01-01&#39;),(2,&#39;2&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789&#39;,&#39;2000-01-01&#39;); -- 插入两条数据
</code></pre>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre><code class="sql">UPDATE 表名 SET 字段1=值1,字段2=值2,...[WHERE 条件];
</code></pre>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果不指定修改语句的条件,则会修改整张表的所有数据</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>修改id为1的数据,将name修改为 abc</p>
<pre><code class="sql">update employee set name = &#39;abc&#39; where id = 1;
</code></pre>
<p>修改id为1的数据,name修改为 小赵,gender修改为 女</p>
<pre><code class="sql">update employee set name = &#39;小赵&#39;, gender = &#39;女&#39; where id = 1;
</code></pre>
<p>将所有员工入职日期修改为 2008-01-01</p>
<pre><code class="sql">update employee set entry_data = &#39;2008-01-01&#39;;
</code></pre>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><pre><code class="sql">DELETE FROM 表名 [WHERE 条件];
</code></pre>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p>delete语句如果不指定条件,则会删除整张表格数据(相当于truncate table 表名;)<br>delete只能删除一条数据,如果要删除一个字段的值,使用update</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>删除gender为女的员工</p>
<pre><code class="sql">delete from employee where gender = &#39;女&#39;;
</code></pre>
<p>删除所有员工</p>
<pre><code class="sql">delete from employee;
truncate table employee;
</code></pre>
<h2 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h2><p>Data Query Language, 数据查询语言</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>SELECT 字段列表</p>
<p>FROM 表名列表</p>
<p>WHERE 条件列表</p>
<p>GROUP BY 分组字段列表</p>
<p>HAVING 分组后条件列表</p>
<p>ORDER BY 排序字段列表</p>
<p>LIMIT 分页参数</p>
<p>基本查询 仅用 select from</p>
<p>条件查询 where</p>
<p>聚合函数 count max min avg sum</p>
<p>分组查询 group by 通常配合聚合函数</p>
<p>排序查询 order by</p>
<p>分页查询 limit</p>
<h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><ol>
<li>查询多个字段</li>
</ol>
<pre><code class="sql">SELECT 字段1,字段2,字段3... FROM 表名;
SELECT * FROM 表名;
</code></pre>
<ol start="2">
<li>设置别名</li>
</ol>
<pre><code class="sql">SELECT 字段1 [AS 别名1],字段2 [AS 别名2] ... FROM 表名; -- 在设置别名时, as可以省略
</code></pre>
<ol start="3">
<li>去除重复记录</li>
</ol>
<pre><code class="sql">select distinct 字段列表 from 表名; -- 对查询结果去重
</code></pre>
<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><p>在开发中,尽量不写*,因为不直观,会影响效率</p>
<p>别名可以加引号,也可以不加引号,推荐加引号;后面使用别名时,则不能加引号</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询指定字段name,workno,age返回</li>
</ol>
<pre><code class="sql">select name,workno,age from emp;
</code></pre>
<ol start="2">
<li>查询所有字段返回</li>
</ol>
<pre><code class="sql">select * from emp;
</code></pre>
<ol start="3">
<li>查询所有员工工作地址,起别名</li>
</ol>
<pre><code class="sql">select address as &#39;工作地址&#39; from emp;
select address &#39;工作地址&#39; from emp;
</code></pre>
<ol start="4">
<li>查询公司员工上班地址(数据不重复)</li>
</ol>
<pre><code class="sql">select distinct address from emp;
</code></pre>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><pre><code class="sql">SELECT 字段列表 FROM 表名 WHERE 条件列表;
</code></pre>
<p>条件列表中可以有条件运算符,具体有</p>
<p>&gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D; &lt;&gt;或!&#x3D;  注意比较相等是&#x3D;</p>
<p>BETWEEN … AND …  在某范围内(含)</p>
<p>IN(…)  在in后列表中的值,多选一</p>
<p>LIKE 占位符 模糊匹配,占位符有_和%,其中_匹配单个字符,%匹配任意字符</p>
<p>IS NULL 是NULL</p>
<p>逻辑:</p>
<p>AND或&amp;&amp;, OR或||, NOT或!</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询年龄等于88地员工</li>
</ol>
<pre><code class="sql">select * from emp where age = 88;
</code></pre>
<ol start="2">
<li>查询年龄小于20地员工</li>
</ol>
<pre><code class="sql">select * from emp where age &lt; 20;
</code></pre>
<ol start="3">
<li>查询年龄小于等于20地员工</li>
</ol>
<pre><code class="sql">select * from emp where age &lt;= 20;
</code></pre>
<ol start="4">
<li>查询没有身份证号的员工</li>
</ol>
<pre><code class="sql">select * from emp where id_card is null;
</code></pre>
<ol start="5">
<li>查询有身份证号的员工</li>
</ol>
<pre><code class="sql">select * from emp where id_card is not null;
</code></pre>
<ol start="6">
<li>查询年龄不等于88的员工</li>
</ol>
<pre><code class="sql">select * from emp where age != 88;
</code></pre>
<ol start="7">
<li>查询年龄在15(含)到20含的员工</li>
</ol>
<pre><code class="sql">select * from emp where age between 15 to 20;
</code></pre>
<ol start="8">
<li>查询性别为 女 且年龄小于25岁的员工</li>
</ol>
<pre><code class="sql">select * from emp where gender = &#39;女&#39; and age &lt; 25;
</code></pre>
<ol start="9">
<li>查询年龄等于18或20或40的员工</li>
</ol>
<pre><code class="sql">select * from emp where age in (18,20,40);
</code></pre>
<ol start="10">
<li>查询姓名为两个字的员工</li>
</ol>
<pre><code class="sql">select * from emp where name like &#39;__&#39;;
</code></pre>
<ol start="11">
<li>查询身份证最后一位为X的员工</li>
</ol>
<pre><code class="sql">select * from emp where idcard like &#39;%X&#39;;
</code></pre>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体,进行纵向计算</p>
<p>常见聚合函数: count max min avg sum</p>
<h4 id="用法-5"><a href="#用法-5" class="headerlink" title="用法"></a>用法</h4><pre><code class="sql">SELECT 聚合函数(字段列表) FROM 表名;
</code></pre>
<h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><p>null值不参与计算</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><ol>
<li>统计该企业员工数量</li>
</ol>
<pre><code class="sql">select count(*) from emp;
</code></pre>
<ol start="2">
<li>统计该企业员工平均年龄</li>
</ol>
<pre><code class="sql">select avg(age) from emp;
</code></pre>
<ol start="3">
<li>统计该企业员工最大年龄</li>
</ol>
<pre><code class="sql">select max(age) from emp;
</code></pre>
<ol start="4">
<li>统计该企业员工最小年龄</li>
</ol>
<pre><code class="sql">select min(age) from emp;
</code></pre>
<ol start="5">
<li>统计西安地区员工年龄之和</li>
</ol>
<pre><code class="sql">select sum(age) from emp where work_address = &#39;西安&#39;;
</code></pre>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];
</code></pre>
<h4 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h4><p>where与having 区别</p>
<ol>
<li>执行时机不同: where在分组前过滤,而having在分组后过滤</li>
<li>判断条件不同:where不能对聚合函数进行判断,而having可以</li>
</ol>
<p>执行顺序: where-&gt;聚合函数-&gt;having</p>
<p>分组后,查询的字段为聚合函数或分组字段,查询其他字段无任何意义</p>
<p>如果在sql模式中启用了ONLY_FULL_GROUP_BY,则select不允许查询group by中没有的字段,或没有使用聚合函数进行处理,如</p>
<pre><code class="sql">select gender,name from emp group by gender; --Error!
</code></pre>
<p>是错误的,而如果使用聚合函数进行处理,则</p>
<pre><code class="sql">select gender,count(*) from emp group by gender; -- Correct!
</code></pre>
<p>则可以执行</p>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><ol>
<li>根据性别分组, 统计男性员工和女性员工数量</li>
</ol>
<pre><code class="sql">select gender,count(*) from emp group by gender;
select name,count(*) from emp group by gender; -- name字段无任何意义,因为只有两行gender,对应的name没有意义(只是展示了第一个的名字)
select count(*) from emp group by gender; -- 可以执行但无法实现要求,因为不会显示gender(无法知道哪个性别的是多少个人)
</code></pre>
<ol start="2">
<li>根据性别分组,统计男性员工和女性员工平均年龄</li>
</ol>
<pre><code class="sql">select gender,avg(age) from emp group by gender;
</code></pre>
<ol start="3">
<li>查询年龄小于45的员工,并根据工作地址分组,获取员工数量大于等于3的工作地址</li>
</ol>
<pre><code class="sql">select work_address,count(*) from emp where age &lt; 45 group by work_address having count(*) &gt;=3; -- 直接查询对应年龄的员工后,再分组,再获取员工数量大于等于3的地址

select work_address,count(*) address_count from emp where age&lt;45 group by work_address having address_count &gt;= 3;
</code></pre>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><h4 id="用法-6"><a href="#用法-6" class="headerlink" title="用法"></a>用法</h4><pre><code class="sql">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;
</code></pre>
<p>排序方式: ASC:升序(默认值) DESC: 降序</p>
<h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果多字段排序,先排第一个,在第一个基础上排第二个字段</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><ol>
<li>根据年龄对公司员工进行升序排序</li>
</ol>
<pre><code class="sql">select * from emp order by age asc;
</code></pre>
<ol start="2">
<li>根据入职时间,对员工进行降序排序;</li>
</ol>
<pre><code class="sql">select * from emp order by entry_date desc;
</code></pre>
<ol start="3">
<li>根据年龄对公司的员工进行升序排序;若年龄相同,再按照入职时间降序排序</li>
</ol>
<pre><code class="sql">select * from emp order by age asc, entry_date desc;
</code></pre>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><h4 id="用法-7"><a href="#用法-7" class="headerlink" title="用法"></a>用法</h4><pre><code class="sql">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;
</code></pre>
<p>起始索引从0开始, 起始索引&#x3D; (查询页码-1)*每页显示记录数</p>
<p>分页查询是数据库的方言,不同数据库有不同实现,如mysql中是LIMIT (方言:指数据库之间不同的差异)</p>
<p>若是第一页数据,则起始索引可以省略,简写为limit 10;</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询第一页员工数据,每页10条记录</li>
</ol>
<pre><code class="sql">select * from emp limit 10;
</code></pre>
<ol start="2">
<li>查询第二页员工数据,每页10条</li>
</ol>
<pre><code class="sql">select * from emp limit 10,10;
</code></pre>
<h3 id="关于MYSQL的模糊查询"><a href="#关于MYSQL的模糊查询" class="headerlink" title="关于MYSQL的模糊查询"></a>关于MYSQL的模糊查询</h3><p>% 百分号通配符, 表任意字符出现任意次数(含0次,相当于.*)</p>
<p>_ 下划线通配符,表单个任意字符,相当于.</p>
<p>若like后没有使用%和_,则与&#x3D;相同</p>
<p>转义: ESCAPE关键字(指定转义符)</p>
<p>如’%&#x2F;_%’escape’&#x2F;‘; 指定 &#x2F; 为转义符,则对其中的_进行了转义</p>
<p>‘%_%’ escape ‘&#39;; 指定 \ 为转义符</p>
<h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><p>模糊查询消耗性能更多<br>如果一定要使用时,则不要把通配符放在开始处(否则将全库扫描,速度最慢)</p>
<h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><ol>
<li>查询年龄为20,21,22,23的女员工信息</li>
</ol>
<pre><code class="sql">select * from emp where gender = &#39;女&#39; age in (20,21,22,23);
</code></pre>
<ol start="2">
<li>查询性别为男,并且年龄在20-40(含)以内姓名为三个字的员工</li>
</ol>
<pre><code class="sql">select * from emp where gender = &#39;男&#39; and (age between 20 and 40) and name like &#39;___&#39;;
</code></pre>
<ol start="3">
<li>统计员工表中,年龄小于60岁,男性员工和女性员工的人数</li>
</ol>
<pre><code class="sql">select gender,count(*) where age &lt; 60 group by gender;
</code></pre>
<ol start="4">
<li>查询所有年龄小于等于35岁员工的姓名和年龄,并对查询结果按照年龄升序排序,如果年龄相同按入职时间顺序降序排序</li>
</ol>
<pre><code class="sql">select name,age from emp where age &lt;= 35 order by age asc, entry_time desc;
</code></pre>
<ol start="5">
<li>查询性别为男,且年龄在20-40岁(含)以内前5个员工信息,对查询结果按年龄升序,年龄相同按入职时间升序</li>
</ol>
<pre><code class="sql">select * from emp where gender = &#39;男&#39; and age between 20 and 40 order by age asc, entry_date asc limit 5;
</code></pre>
<h3 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h3><p>执行顺序: FROM-&gt;WHERE-&gt;GROUP BY,HAVING-&gt;SELECT-&gt;ORDER BY-&gt;LIMIT</p>
<p>编写顺序: SELECT-&gt;FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;ORDER BY-&gt;LIMIT</p>
<h4 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h4><p>虽然SELECT 在 GROUP BY 后执行,但GROUP BY 依然可以使用别名(mysql进行了优化)</p>
<p>WHERE 不可以使用select的别名</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ff7d73">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #03a9f4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/14/sql%E5%AD%A6%E4%B9%A0-%E4%BA%8C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/12/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">SQL学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/12
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>分为DDL,DML,DQL,DCL<br>注释:</p>
<pre><code class="sql">-- 注释
# mysql注释
/*
多行注释
*/
</code></pre>
<h2 id="DDL-Data-Definition-Language"><a href="#DDL-Data-Definition-Language" class="headerlink" title="DDL(Data Definition Language)"></a>DDL(Data Definition Language)</h2><p>负责对库进行操作</p>
<p>查询:</p>
<pre><code class="sql">SHOW DATABASES;
SELECT DATABASE(); -- 查询当前选定的数据库
</code></pre>
<p>创建</p>
<pre><code class="sql">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];
</code></pre>
<p>删除</p>
<pre><code class="sql">DROP DATABASE [IF EXISTS] 数据库名;
</code></pre>
<p>使用</p>
<pre><code class="sql">USE 数据库名;
</code></pre>
<p>查询当前数据库中所有表</p>
<pre><code class="sql">SHOW TABLES;
</code></pre>
<p>查询表结构</p>
<pre><code class="sql">DESC 表名称; --- describe
</code></pre>
<p>查询指定表的建表语句</p>
<pre><code class="sql">SHOW CREATE TABLE 表名;
</code></pre>
<p>创建表:</p>
<pre><code class="sql">CREATE TABLE 表名(
    字段名 字段类型 [COMMENT 字段注释],
    字段名 字段类型 [COMMEBT 字段注释],
...
)[COMMENT 表注释];
</code></pre>
<p>添加字段</p>
<pre><code class="sql">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];
</code></pre>
<p>修改字段</p>
<p>修改数据类型</p>
<pre><code class="sql">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);
</code></pre>
<p>修改字段名和字段类型</p>
<pre><code class="sql">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];
</code></pre>
<p>删除字段</p>
<pre><code class="sql">ALTER TABLE 表名 DROP 字段名;
</code></pre>
<p>修改表名</p>
<pre><code class="sql">ALTER TABLE 表名 RENAME TO 表名;
</code></pre>
<p>删除表</p>
<pre><code class="sql">DROP TABLE [IF EXISTS] 表名;
TRUNCATE TABLE 表名; -- 删除指定表,并重新创建该表(清空数据) truncate截短,去尾
</code></pre>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code class="sql">CREATE DATABASE IF NOT EXISTS test DEFAULT CHARSET utf8mb4; -- 创建test数据库(如果不存在的话),并以utf8mb4存储(最多4字节)

DROP DATABASE IF EXISTS test; -- 删除test数据库(如果存在的话)
</code></pre>
<p>案例:<br>设计一张员工信息表,要求如下:</p>
<p>1.编号 纯数字</p>
<p>2.员工工号 字符串 长度不超过10位</p>
<p>3.员工姓名 字符串 长度不超10位</p>
<p>4.性别 男&#x2F;女 一个汉字</p>
<p>5.年龄</p>
<p>6.身份证号</p>
<p>7.入职时间 年月日</p>
<pre><code class="sql">CREATE TABLE employee_information(
    id int comment &#39;编号&#39;,
    work_number char(10) comment &#39;工号&#39;,
    name varchar(10) comment &#39;姓名&#39;,
    gender char(1) comment &#39;性别&#39;,
    age tinyint unsigned comment &#39;年龄&#39;,
    id_card char(18) comment &#39;身份证号&#39;,
    entry_date date comment &#39;入职时间&#39;
)comment &#39;员工表&#39;;
</code></pre>
<p>案例</p>
<p>emp表添加字段’昵称’为nickname,varchar(20)</p>
<pre><code class="sql">ALTER TABLE emp ADD nickname varchar(20) comment &#39;昵称&#39;
</code></pre>
<p>案例:</p>
<p>将emp表的nickname字段修改为uername,类型为varchar(30)</p>
<pre><code class="sql">ALTER TABLE emp CHANGE nickname username varchar(30) comment &#39;用户名&#39;
desc emp;
</code></pre>
<p>案例:</p>
<p>将emp表的username字段删除</p>
<pre><code class="sql">ALTER TABLE emp DROP username;
</code></pre>
<p>案例:</p>
<p>将emp表的表名修改为employee</p>
<pre><code class="sql">ALTER TABLE emp RENAME TO employee
</code></pre>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>mysql中主要分为三类: 数值类型, 字符串类型, 日期时间类型</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th align="right">大小</th>
<th align="center">有符号范围</th>
<th align="center">无符号范围</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td align="right">1byte</td>
<td align="center">$$(-2^7,2^7-1)$$</td>
<td align="center">$$(0,2^8-1)$$</td>
<td align="center">小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td align="right">2byte</td>
<td align="center">$$(-2^15,2^15-1)$$</td>
<td align="center">$$(0,2^16-1)$$</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td align="right">3byte</td>
<td align="center">$$(-2^23,2^23-1)$$</td>
<td align="center">$$(0,2^24-1)$$</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td>INT &#x2F; INTEGER</td>
<td align="right">4byte</td>
<td align="center">$$(-2^31,2^31-1)$$</td>
<td align="center">$$(0,2^32-1)$$</td>
<td align="center">大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td align="right">8byte</td>
<td align="center">$$(-2^63,2^63-1)$$</td>
<td align="center">$$(0,2^64-1)$$</td>
<td align="center">极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td align="right">4byte</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">单精度浮点数</td>
</tr>
<tr>
<td>DOUBLE</td>
<td align="right">8byte</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">双精度浮点数</td>
</tr>
<tr>
<td>DECIMAL</td>
<td align="right">-</td>
<td align="center">依赖于M(精度)和D(标度)的值</td>
<td align="center">依赖于M(精度)和D(标度)的值</td>
<td align="center">小数值(精确定点数)</td>
</tr>
</tbody></table>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>DECIMAL: 如123.45,则精度M为整个长度,即5;D表小数位数,即2</p>
<p>age TINYINT UNSIGNED</p>
<p>score DOUBLE(4,1) –  4代表整体长度,1代表小数位数 (已经不推荐)</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>TINYINT 枚举变量</p>
<p>SMALLINT 较小数据的统计量,如工厂固定资产的统计数量</p>
<p>MEDIUMINT 较大数据的统计量,如车站每日客流量</p>
<p>INT,INTEGER 足够大了,一般不需要考虑超值问题,如商品编号</p>
<p>BIGINT 需要处理特别大的数据时使用,如大型网站点击量,双十一交易量等</p>
<p>浮点类型不建议使用UNSIGNED或SIGNED,和float(M,D)等等</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>$$(0,2^8-1)$$</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>$$(0,2^16-1)$$</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>$$(0,2^8-1)$$</td>
<td>二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>$$(0,2^8-1)$$</td>
<td>短文本数据</td>
</tr>
<tr>
<td>BLOB</td>
<td>$$(0,2^16-1)$$</td>
<td>二进制数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>$$(0,2^16-1)$$</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>$$(0,2^24-1)$$</td>
<td>二进制数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>$$(0,2^24-1)$$</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>$$(0,2^36-1)$$</td>
<td>二进制数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>$$(0,2^36-1)$$</td>
<td>超大文本&#96;数据</td>
</tr>
</tbody></table>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">char(10)
varchar(50) -- 最多五十位
</code></pre>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>BLOB 表二进制数据,但一般不用(性能不高,不方便管理),对于二进制数据处理一般采用专门的文件服务器处理</p>
<p>TEXT表示长文本数据</p>
<p>变长: 表大小可变,但是代价是消耗性能多 (如用户名)</p>
<p>定长:大小不变,更快  (如性别)</p>
<h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 , 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 , 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901-2155</td>
<td>YYYY</td>
<td>年份</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 , 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:DD</td>
<td>混合日期与时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 , 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:DD</td>
<td>混合日期与时间值,时间戳</td>
</tr>
</tbody></table>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><p>一般用DATE,TIME,DATETIME更多</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #00bcd4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #00a596">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/12/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/05/03/HTML%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">HTML学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/3
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML?"></a>什么是HTML?</h1><p>HTML(Hyper Text Markup Language) 超文本标记语言<br>非编程语言,而是标记语言</p>
<h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;!-- 声明为HTML5文档 --&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;这里是标题&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 这是注释 --&gt;
    &lt;!-- body标签表示页面的主要内容--&gt;
    &lt;p&gt;这里是段落&lt;/p&gt;

&lt;/body&gt;
&lt;!-- 注意,所有标签尽可能用/关闭--&gt;
&lt;/html&gt;
</code></pre>
<p>一些标签<br>&lt;p&gt;段落标签,表示一段<br>&lt;h1&gt;-&lt;h6&gt;表示标题<br>&lt;a href&#x3D;”链接”&gt;链接文本&lt;&#x2F;a&gt;<br>&lt;b&gt;表示加粗<br>&lt;s&gt;表示删除线<br>&lt;u&gt;表示下划线<br>&lt;i&gt;表示斜体<br>&lt;sup&gt;表示上标<br>&lt;sub&gt;表示下标<br>&lt;pre&gt;表示以源格式输出<br>&lt;em&gt;表示强调<br>&lt;strong&gt;表示加重语气<br>&lt;q&gt;表示内联引用<br>&lt;blockquote&gt;表示块引用<br>&lt;hr&gt;表示分割线<br>&lt;br&gt;表示换行<br>&lt;span&gt;表示范围内生效(用css)<br>&lt;ul&gt;表示无序列表<br>&lt;ol&gt;表示有序列表<br>&lt;li&gt;表示列表中的元素<br>列表可以嵌套<br>&lt;div&gt;表示分割,并不会表示任何内容,更用于组织内容,如使用css或id等.<br>&lt;section&gt;表示部分<br>应当注意的是,一篇网页应当只有一个main,不同章节用section分割,更小的部分用div.</p>
<p>&lt;html&gt;头内可以有lang属性,标识网页的语言.</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E5%89%8D%E7%AB%AF/" style="color: #ffa2c4">前端</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/HTML/" style="color: #03a9f4">HTML</a>
        </span>
        
    </div>
    <a href="/2024/05/03/HTML%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/05/03/HTML%E5%AD%A6%E4%B9%A0-%E4%BA%8C/">
        <h2 class="post-title">HTML学习(二)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/3
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="html元"><a href="#html元" class="headerlink" title="html元"></a>html元</h1><p>使用&lt;meta&gt;标签<br>示例:</p>
<pre><code class="html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;!-- charset属性用于设定文字编码 --&gt;
    &lt;meta name=&quot;author&quot; contents=&quot;dancingby&quot; /&gt;
    &lt;meta name=&quot;description&quot; contents=&quot;here is the description of the website&quot; /&gt;
    &lt;meta name=&quot;keywords&quot; contents=&quot;html&quot; /&gt;
    &lt;!-- 这里是一些自定的网页的表述,同时,元里可以添加其他平台可解析的属性(如twitter与Facebook的) --&gt;
&lt;/head&gt;
</code></pre>
<h1 id="网页架构"><a href="#网页架构" class="headerlink" title="网页架构"></a>网页架构</h1><p>有&lt;header&gt;(页眉),&lt;nav&gt;(导航栏),&lt;article&gt;文章,&lt;main&gt;主要内容,&lt;aside&gt;侧边栏&lt;footer&gt;页尾部分.<br>示例:</p>
<pre><code class="html">&lt;body&gt;
    &lt;header&gt;&lt;h1&gt;
        This is header.
        &lt;/h1&gt;&lt;/header&gt;
    &lt;nav&gt;
    &lt;ul&gt;
        &lt;li&gt;
        主页&lt;/li&gt;
        &lt;li&gt;
        文章&lt;/li&gt;
        &lt;/ul&gt;
        &lt;form&gt;
            &lt;input type=&quot;search&quot; name = &quot;s&quot; placeholder = &quot;Pleace type to search&quot; /&gt;
            &lt;input type = &quot;submit&quot; value=&quot;search&quot; /&gt;
        &lt;/form&gt;
    &lt;/nav&gt;
    &lt;main&gt;
    &lt;article&gt;
        文章主要内容
        &lt;/article&gt;
        &lt;aside&gt;
        &lt;h2&gt;
            相关链接
            &lt;/h2&gt;
        &lt;ul&gt;
            &lt;li&gt;
            &lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;
            &lt;a href = &quot;https://dancingby0.github.io&quot;&gt;
                dancingby&#39;s blog.
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/aside&gt;
    &lt;/main&gt;
    &lt;footer&gt;
    &lt;p&gt;
        
        all rights reserved.
        &lt;/p&gt;&lt;/footer&gt;
&lt;/body&gt;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/%E5%89%8D%E7%AB%AF/" style="color: #03a9f4">前端</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/HTML/" style="color: #00bcd4">HTML</a>
        </span>
        
    </div>
    <a href="/2024/05/03/HTML%E5%AD%A6%E4%B9%A0-%E4%BA%8C/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">2</a>
    
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">dancingby</div>
        <div class="description">
            <p>Description<br>dancingbyです！</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://github.com/dancingby0">github</a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://afdian.net/a/dancingby">爱发电</a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 dancingby&#39;s home
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;dancingby
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
