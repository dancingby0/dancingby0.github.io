
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>dancingby&#39;s home</title>
    <meta name="author" content="dancingby" />
    <meta name="description" content="" />
    <meta name="keywords" content="blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>DANCINGBY&#39;S HOME</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;DANCINGBY&#39;S HOME</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>dancingby&#39;s home</h1>
                <h3>dancingbyのblogs</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/09/24/Lombok-Junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/">
        <h2 class="post-title">Lombok,Junit,反射,注解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h1><p>进行代码测试,即进行白箱测试</p>
<p>建议:</p>
<ol>
<li>测试类名: CalculatorTest</li>
<li>包名: xxx.xxx.xxx.xx.test cn.itcast.test</li>
</ol>
<p>定义测试方法:</p>
<p>可以独立运行</p>
<ol>
<li>方法名: test测试方法名 testAdd</li>
<li>返回值 void</li>
<li>形参列表 空</li>
<li>加上@Test注解</li>
</ol>
<p>判定结果 红色成功,绿色失败;一般使用断言操作处理操作</p>
<p>在测试方法中进行断言,断言结果为需要的结果,如果断言失败,则说明程序有问题</p>
<pre><code class="java">Assert.assertEquals(a+b,result); // 如果与期望的值不同,则报错
</code></pre>
<p>常见注解:</p>
<p>@Test 表明该方法是测试方法</p>
<pre><code class="java">public class CalculatorTest&#123;
    @Before // 说明在所有测试方法执行前都会调用该方法(用于申请资源)
    public void init()&#123;
        System.out.println(&quot;init...&quot;);
    &#125;
    @After // 在所有测试方法执行后都会调用该方法(用于释放资源)
    public void close()&#123;
        System.out.println(&quot;close...&quot;);
    &#125;

    @Test
    public void testAdd()&#123;
        Calculator c = new Calculator();
        int result = c.sub(1,2);
        Assert.assertEquals(3,result); // 即便失败,还是会执行close方法
    &#125;
&#125;
</code></pre>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>框架设计的灵魂</p>
<p>框架: 半成品软件(简化编码)</p>
<p>反射:将类的各个组成部分</p>
<p>好处:</p>
<ol>
<li><p>在程序运行中,可以操作这些对象</p>
</li>
<li><p>可以解耦,提高程序的可拓展性</p>
</li>
</ol>
<p>获取class对象(字节码对象)的方式</p>
<ol>
<li><p>Class.forName(“全类名”): 将字节码文件加载进内存,返回class对象 (源代码阶段) 多用于配置文件,将类名定义于配置文件中,读取文件加载类</p>
</li>
<li><p>类名.class : 通过类名的属性获取 (类对象阶段) 多用于参数传递</p>
</li>
<li><p>对象.getClass() : getClass()方法在Object类中定义 (Runtime时阶段) 多用于对象获取字节码方式</p>
</li>
</ol>
<p>结论: 同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次; <strong>不管使用什么方式加载,都是同一个对象</strong></p>
<p>&#x2F;&#x2F; java.lang.ClassNotFoundException: 无法找到类(类名可能写错了)</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Class对象功能"><a href="#Class对象功能" class="headerlink" title="Class对象功能:"></a>Class对象功能:</h3><p>获取功能:</p>
<ol>
<li>成员变量们<ul>
<li>Field[] getFields() &#x2F;&#x2F; 获取可访问的公共字段(public),包括父类</li>
<li>Field getField(String name) &#x2F;&#x2F; 获取指定名称的公共字段,</li>
<li>Field[] getDeclaredFields() &#x2F;&#x2F; 获取可访问的所有字段(不考虑修饰符),不包括父类</li>
<li>Field getDeclaredField(String name) &#x2F;&#x2F;</li>
</ul>
</li>
<li>构造方法们</li>
</ol>
<p>同上,详见文档</p>
<ol start="3">
<li><p>获取成员方法们</p>
</li>
<li><p>类名等</p>
</li>
</ol>
<pre><code class="java">Field[] fields = personClass.getFields();
</code></pre>
<h3 id="字段功能"><a href="#字段功能" class="headerlink" title="字段功能"></a>字段功能</h3><p>Field 成员变量</p>
<ol>
<li>设置值</li>
</ol>
<p>void set(Object obj, Object value) &#x2F;&#x2F; 对于特定obj的字段设置value值</p>
<ol start="2">
<li>获取值</li>
</ol>
<ul>
<li>get(Object obj)</li>
</ul>
<ol start="3">
<li>忽略访问权限修饰符安全检查<br>setAccessible(true): 暴力反射(忽略了private这种,破坏封装)</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>创建对象</p>
<pre><code class="java">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) // 获取特定的构造方法 同理,declared可以获取私有的构造器,但也需要调用构造器的setAccessible进行暴力反射

T newInstance(Object... initargs)// 通过构造方法创建实例
</code></pre>
<p>如果使用空参,操作可以简化:Class对象的newInstance方法</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Method: 方法对象</p>
<p>Object invoke(Object obj, Object… args) &#x2F;&#x2F; 对obj执行特定方法</p>
<p>获取方法名称:</p>
<p>String getName() &#x2F;&#x2F; 获取方法名</p>
<pre><code class="java">// 获取指定名称方法
Method eat_method = personClass.getMethod(&quot;eat&quot;);
Person p = new Person();
eat_method.invoke(p); // 空参方法

Method[] methods = personClass.getMethods();
for(Method method : methods)&#123;
    System.out.println(method.getName());
&#125;
</code></pre>
<p>示例:</p>
<pre><code class="java">Constructor constructor = personClass.getConstructor(String.class,int.class);
Object person = constructor.Instance(&quot;张三&quot;,23);
Object person1 = personClass.newInstance();
</code></pre>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需求:</p>
<p>创建框架,可以帮我们创建任意类的对象,并执行其中任意方法</p>
<p>实现:</p>
<ol>
<li><p>配置文件</p>
</li>
<li><p>反射</p>
</li>
</ol>
<p>步骤:</p>
<ol>
<li><p>将需要创建的对象全类名和需要执行的方法定义在配置文件中</p>
</li>
<li><p>在程序中加载读取配置文件</p>
</li>
<li><p>使用反射技术加载类文件进入内存,创建对象,执行方法</p>
</li>
</ol>
<pre><code class="ini">className=cn.itcast.domain.Person
methodName=eat
</code></pre>
<pre><code class="java">public class ReflectTest&#123;
    public static void main(String[] args) throws Exception&#123;
        Properties pro = new Properties();
        ClassLoader classLoader = ReflectTest.class.getClassLoader(); // 获取class目录下类加载器
        InputSteam is =  classLoader.getResourceAsStream(&quot;pro.properties&quot;);
        pro.load(is);
        String className = pro.getProperty(&quot;className&quot;);
        String methodName = pro.getProperty(&quot;methodName&quot;);

        Class cls = Class.forName(className);
        Object obj = cls.newInstance();

        Method method = cls.getMethod(methodName);

        method.invoke(obj);
    &#125;
&#125;
</code></pre>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>概念:</p>
<p>用文字描述程序,给程序员看的;JDK1.5之后才有</p>
<p>使用@注解名称</p>
<p>作用分类:</p>
<ol>
<li><p>编写文档(生成doc文档)</p>
</li>
<li><p>代码分析(使用反射)</p>
</li>
<li><p>编译检查(Override),让编译器能够实现基本的编译检查</p>
</li>
</ol>
<pre><code class="java">/**
 * @author test
 * @since 1.5
 */
public class Demo1&#123;

    /**
     * 计算两数和
     * @param a 整数
     * @param b 整数
     * @return 两数和
     */
    public int add(int a,int b)&#123;
        return a + b;
    &#125;
&#125;
</code></pre>
<pre><code class="bash">javadoc Demo1.java # 生成java文档
</code></pre>
<h2 id="JDK预定义注解"><a href="#JDK预定义注解" class="headerlink" title="JDK预定义注解"></a>JDK预定义注解</h2><ul>
<li>@Override: 检测该注解标注的方法是否继承自父类(父接口)</li>
<li>@Deprecated: 将该注解标注的内容,表示已过时</li>
<li>@SuppressWarnings: 压制警告</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>格式:</p>
<p>元注解<br>public @interface 注解名称()</p>
<p>本质:</p>
<p>注解本质上就是一个接口,默认继承自Annotation包(通过反编译得到) 因此操作和接口相同</p>
<p>public interface MyAnno extends java.lang.annotation.Annotation{}</p>
<p>属性:</p>
<p>接口可以定义的成员方法</p>
<p>要求:</p>
<p>返回值类型:</p>
<ol>
<li><p>基本数据类型</p>
</li>
<li><p>String</p>
</li>
<li><p>枚举</p>
</li>
<li><p>注解</p>
</li>
<li><p>以上类型的数组</p>
</li>
</ol>
<p>定义了属性(抽象方法),在使用时需要给属性赋值</p>
<p>使用default关键字给属性默认初始化值,则使用注解时可以不赋值</p>
<p>如果只有一个属性需要赋值,且名称是value,则名称可以省略,@SuppressWarnings(‘all’),这个all就是给value赋值</p>
<p>数组赋值时,需要用大括号;如果只有一个值,大括号可以省略</p>
<p>元注解:</p>
<p>用于描述注解的 注解(就是一个注解,但是它用来描述注解)</p>
<p>@Target: 描述注解能够作用的位置</p>
<p>@Retention: 描述注解被保留的阶段(有三个阶段,源码,Class,Runtime阶段)</p>
<p>@Documented: 描述注解是否被抽取至api文档中</p>
<p>@Inherited: 描述注解是否被子类继承</p>
<h2 id="使用-解析-注解"><a href="#使用-解析-注解" class="headerlink" title="使用(解析)注解"></a>使用(解析)注解</h2><pre><code class="java">@SuppressWarnings(&quot;all&quot;) // 需要传参,一般传all

public @interface MyAnno&#123;
    public abstract String show();
    int show1();
    String show2() default &quot;张三&quot;; // 默认张三
    Person per(); // 返回枚举类型

    String[] strs()

    int value();

&#125;

@MyAnno(show1 = 1,show2 = &quot;2&quot;,per = Person.p1,strs = &#123;&quot;aaa&quot;,&quot;bbb&quot;&#125; ) // 使用时像属性,需要赋值
</code></pre>
<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>简介:</p>
<p>Lombok是一个Java库,能够自动插入编辑器并构建工具,简化Java开发</p>
<p>他用注解进行提高代码可读性和开发效率(即只需要在Java类上添加相应注解,不需要手动编写相应代码)</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/24/Lombok-Junit-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/22/JAVA-JDBC%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">JAVA JDBC学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDBC就是用Java语言操作关系型数据库的一套API</p>
<p>JDBC(Java DataBase Connectivity)</p>
<p>期望用一套java代码操作不同关系型数据库</p>
<p>Sun公司提出JDB标准接口,而MySQL,ORACLE等自己实现这套接口(即MySQL驱动,ORACLE驱动,即数据库驱动jar包,面向接口编程)</p>
<p>我们可以使用这套接口编程,真正执行代码的是驱动jar包的实现类</p>
<p>步骤:</p>
<ol start="0">
<li>创建工程,导入驱动jar包</li>
</ol>
<p>mysql-connector-java-x.x.x.jar</p>
<ol>
<li>注册驱动</li>
</ol>
<pre><code class="java">Class.forName(&quot;com.mysql.jdbc.Drivaer&quot;); // 反射,将mysql的驱动类加载进内存
</code></pre>
<ol start="2">
<li>获取连接</li>
</ol>
<pre><code class="java">Connection.conn = DriverManager.getConnection(url,username,password);
</code></pre>
<ol start="3">
<li>定义SQL语句</li>
</ol>
<pre><code class="java">String sql = &quot;update...&quot;;
</code></pre>
<ol start="4">
<li>获取执行SQL对象</li>
</ol>
<pre><code class="java">Statement stmt = conn.createStatement();
</code></pre>
<ol start="5">
<li>执行SQL</li>
</ol>
<p>实际上是将sql语言发送给mysql数据库,让mysql数据库去执行</p>
<pre><code class="java">stmt.executeUpdate(sql);
</code></pre>
<ol start="6">
<li><p>处理返回结果</p>
</li>
<li><p>释放资源</p>
</li>
</ol>
<pre><code class="java">stmt.close();
conn.close();
</code></pre>
<h1 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>驱动管理类,作用</p>
<ol>
<li><p>注册驱动</p>
</li>
<li><p>获取数据库连接</p>
</li>
</ol>
<p>当使用反射把驱动加载进内存时,其类的静态代码块自动将mysql驱动注册</p>
<p>在MySQL5后,Class.forName(“com.mysql.jdbc.Driver”)可不写,因为其自动加载META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</p>
<ul>
<li>获取连接</li>
</ul>
<pre><code class="java">static Connection = getConnection(String url,String user, String password);
</code></pre>
<ol>
<li>url:连接路径</li>
</ol>
<p>语法: jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2…</p>
<p>如: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1</p>
<p>协议: jdbc:mysql</p>
<p>若连接本地mysql服务器,并且默认端口为3306,则ip地址:端口号可不写,如</p>
<p>jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称?键值对</p>
<p>配置useSSL&#x3D;false参数禁用安全连接方式,解决警告提示</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>数据库连接对象,作用:</p>
<ol>
<li><p>获取执行SQL的对象</p>
</li>
<li><p>管理事务</p>
</li>
</ol>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ol>
<li>获取执行SQL的对象</li>
</ol>
<ul>
<li>普通执行SQL对象</li>
</ul>
<pre><code class="java">Statement createStatement();
</code></pre>
<ul>
<li>预编译SQL执行SQL对象:防止SQL注入</li>
</ul>
<pre><code class="java">PreparedStatement prepareStatement(sql);
</code></pre>
<ul>
<li>执行存储过程的对象</li>
</ul>
<pre><code class="java">CallableStatement prepareCall(sql);
</code></pre>
<p>示例:</p>
<pre><code class="java">Statement stmt = createStatement();
</code></pre>
<ol start="2">
<li>事务管理</li>
</ol>
<p>JDBC事务管理: Connection接口定义了3个对应的方法</p>
<pre><code class="java">// 开启事务
setAutoCommit(boolean autoCommit); // true为自动提交事务,false手动提交
commit(); // 提交事务
rollback(); // 回滚事务, 使用try catch,如果产生异常则回滚事务
</code></pre>
<p>示例:</p>
<pre><code class="java">try&#123;
    // 开启事务
    conn.setAutoCommit(false);
    int count1 = stmt.executeUpdate(sql1);
    System.out.prinln(count1);
    int count2 = stmt.executeUpdate(sql2);
    System.out.println(count2);
    conn.commit();
&#125; catch(Exception thowables)&#123;
    conn.rollback();
    throwables.printStackTrace();
&#125;
</code></pre>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>作用: 执行SQL语句</p>
<pre><code class="sql">int executeUpdate(sql) // 执行DML,DDL语句;DML返回影响的行数,DDL执行成功也可能返回0;
ResultSet executeQuery(sql) // 执行DQL语句,返回结果集对象
</code></pre>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>作用:</p>
<p>封装了DQL查询语句的结果</p>
<p>ResultSet stmt.executeQuery(sql) : 执行SQL语句,返回ResultSet对象</p>
<p>获取查询结果:</p>
<pre><code class="java">boolean next() : 将光标向后移动一位;判断是否有效行

返回true,则有效行,有数据
xxx getXxx(参数): 获取数据

如: int getInt(参数)

参数: int 列的编号,从1开始;
String 列的名称
</code></pre>
<p>使用方法:</p>
<pre><code class="java">while(rs.next())&#123;
    // 获取数据
    int id = rs.getInt(1);
    String name = rs.getString(2);
    int money = rs.getInt(3);
&#125;

rs.close();
</code></pre>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><p>继承自Statement,预编译,防止注入</p>
<p>语法:</p>
<pre><code class="java">// 1. 获取PreparedStatement对象
// SQL语句中的参数值用?占位符替代
String sql = &quot;select * from user where user_name = ? and password = ?&quot;;

PreparedStatement pstmt = conn.prepareStatement(sql);

// 2. 设置参数值
// setXxx(?的编号,从1起,?的值)
pstmt.setString(1,name);
pstmt.setString(2,password);

// 3. 执行sql语句

executeUpdate(); // 不需要再传递sql
executeQuery();
</code></pre>
<p>解决注入原理:<br>预编译SQL,性能更高</p>
<p>对?的内容进行转义,而非单纯拼接字符串</p>
<p>MYSQL接受SQL后,首先检查SQL语法,再编译SQL为可执行函数,最后执行SQL</p>
<p>开启预编译功能:</p>
<p>useServerPreStmts &#x3D; true &#x2F;&#x2F; 预编译默认关闭,需要先开启</p>
<ol>
<li>获取PreparedStatement对象时,将sql语句发送给mysql服务器进行检查,编译(很耗时)</li>
</ol>
<p>开启方法:</p>
<pre><code class="java">String url = &quot;jdbc:mysql://localhost:3306/db1?useSSL=false&amp;useServerPreStmts=true&quot;;
</code></pre>
<ol start="2">
<li><p>执行时则不需要再进行</p>
</li>
<li><p>如果sql模板一样,则只需要一次检查编译</p>
</li>
</ol>
<p>如:</p>
<pre><code class="java">sql = &quot;select * from user where user_name = ? and password = ?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.set(1,name);
pstmt.set(2,password);
Result rs = pstmt.executeUpdate();
// 只会预编译一次,提升性能
pstmt.set(1,name);
pstmt.set(2,password);
rs = pstmt.executeUpdate();
</code></pre>
<p>配置MySQL执行日志:</p>
<pre><code class="ini">log-output=FILE
general-log=1
general_log_file = &quot;D:\mysql.log&quot;
slow-query-log = 1
slow_query_log_file=&quot;D:\mysql_slow.log&quot;
long_query_time = 2
</code></pre>
<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>是个容器,负责分配,管理数据库连接</p>
<p>允许应用程序重复使用一个现有的数据库连接,而非重新建立一个</p>
<p>释放空闲时间超过最大空闲时间的数据库连接防止因为没有释放数据库连接而引起数据库连接遗漏 (即如果创建了数据库连接而太长时间不用,则会自动释放)</p>
<p>好处:</p>
<p>资源重用</p>
<p>提升系统响应速度</p>
<p>避免数据库连接遗漏</p>
<p>实现:</p>
<p>标准接口: DataSource</p>
<p>SUN提供地数据库连接池标准接口,由第三方组织实现此接口</p>
<p>功能:获取连接</p>
<p>常用数据库连接池:</p>
<p>DBCP,C3P0,Druid</p>
<pre><code class="java">Connection getConnection();
</code></pre>
<h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p>使用步骤:</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>定义配置文件</p>
</li>
<li><p>加载配置文件</p>
</li>
<li><p>获取数据库连接池对象</p>
</li>
<li><p>获取连接</p>
</li>
</ol>
<p>配置参数:</p>
<p>名称: druid.properties</p>
<p>driverClassName &#x3D; com.mysql.jdbc.Driver &#x2F;&#x2F; 驱动类名</p>
<p>url &#x3D; jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&amp;useServerPrepStmts&#x3D;true &#x2F;&#x2F; 启动预编译</p>
<p>username&#x3D;root</p>
<p>password&#x3D;1234</p>
<p>initialSize&#x3D;5 &#x2F;&#x2F; 初始化连接数量</p>
<p>maxActive &#x3D; 10 &#x2F;&#x2F; 最大连接数量</p>
<p>maxWait&#x3D;3000 &#x2F;&#x2F; 最大等待时间(ms)</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code class="java">// 3. 加载配置文件
Properties prop = new Properties();
prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;)); // 可能会报错,找不到路径

// 4. 获取连接池对象
DataSource dataSource =  DruidDataSourceFactory.createDataSource(prop);


// 5. 获取数据库连接
Connection conn = dataSource.getConnection();

// 找不到路径解决方案:

System.out.println(Statem.getProperty(&quot;user.dir&quot;)); // 打印用户目录,查看目前所在的路径
</code></pre>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>环境:</p>
<p>数据库表 tb_brand; 实体类 Brand </p>
<pre><code class="sql">drop table if exists tb_brand;
create table tb_brand(
    id int primary key auto_increment;
    brand_name varchar(20),
    company_name varchar(20),
    ordered int,
    description varchar(100),
    status int
);
insert into tb_brand values (...)...
</code></pre>
<p>&#x2F;&#x2F; 在pojo中,尽可能使用其包装类型,因为其默认值为null,不会对业务产生影响</p>
<pre><code class="java">// 把所有字段塞进去,塞入对应getter和setter,重写toString方法;(快捷键:Alt+Insert)
</code></pre>
<p>操作</p>
<pre><code class="java">
public class BrandTest&#123;

    @Test
    public void testSelectAll throws Exception()&#123;
        Properties prop = new Properties()
        prop.load(new FileInputStream(&quot;jdbc-demo/src/druid.properties&quot;));
        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);
        Connection conn=dataSource.getConnection();

        String sql = &quot;select * from tb_brand&quot;;
        PreparedStatement pstmt = conn.prepareStatement(sql);
        ResultSet rs = pstmt.executeQuery();
        while(rs.next())&#123;

            Brand a = new Brand();
            a.setId(rs.getInt(1));
            ...
        &#125;
    &#125;
&#125;
</code></pre>
<p>增删改同理</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/22/JAVA-JDBC%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/21/Maven%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">Maven学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/21/Maven%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/21/MyBatis%E5%AD%A6%E4%B9%A0-%E4%B8%80/">
        <h2 class="post-title">MyBatis学习(一)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>MyBatis是优秀的持久层框架,用于简化JDBC开发</p>
<p>本身是Apache的开源项目iBatis</p>
<h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><ul>
<li><p>负责将数据保存到数据库的那一层代码</p>
</li>
<li><p>JavaEE三层架构: 表现层,业务层,持久层</p>
</li>
</ul>
<p>表现层: 进行页面展示</p>
<p>业务层: 处理业务逻辑</p>
<p>持久层: 将数据持久化(即存储数据)</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>框架就是半成品软件,可重用,通用,软件基础代码模型</p>
<p>框架基础上构建软件编写更有效,规范,通用,可拓展</p>
<h2 id="JDBC缺点"><a href="#JDBC缺点" class="headerlink" title="JDBC缺点"></a>JDBC缺点</h2><ol>
<li>硬编码</li>
</ol>
<p>直接将字符串写入代码内部</p>
<ol start="2">
<li>操作繁琐</li>
</ol>
<h2 id="MyBatis优化"><a href="#MyBatis优化" class="headerlink" title="MyBatis优化"></a>MyBatis优化</h2><p>将硬编码转化到配置文件中</p>
<p>操作繁琐则自动完成</p>
<p>相关持久层框架: Spring Data JPA, MyBatis-Plus…</p>
<p>术语:</p>
<p>POJO(Plain Old Java Object),普通java对象</p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>步骤:</p>
<ol>
<li><p>创建数据表,添加数据</p>
</li>
<li><p>创建项目模块,导入坐标</p>
</li>
<li><p>编写MyBatis核心配置文件,替换数据库连接信息</p>
</li>
<li><p>编写SQL映射文件,统一管理sql语句,解决硬编码问题</p>
</li>
<li><p>编码</p>
<ol>
<li>定义POLO类</li>
<li>加载核心配置文件,获取SqlSessionFactory对象</li>
<li>获取SqlSession对象,执行SQL语句</li>
<li>释放资源</li>
</ol>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/09/21/MyBatis%E5%AD%A6%E4%B9%A0-%E4%B8%80/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/21/SQL%E5%AD%A6%E4%B9%A0-%E4%B9%9D-%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">
        <h2 class="post-title">SQL学习(九)视图,存储过程,触发器</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图(View)是一种虚拟存在的表,视图中的数据并不在数据库中实际存在.定义视图时的表是动态生成的,其原来的表称为基表</p>
<p>即:视图只保存了查询的SQL逻辑,不保存查询结果.(将一堆sql语句整合成一个表使用)</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>创建</li>
</ul>
<pre><code class="sql">create [or replace] view 视图名称[(列名列表)] AS SELECT语法 [WITH [CASCADED|LOCAL] CHECK OPTION];
</code></pre>
<ul>
<li>查询</li>
</ul>
<pre><code class="sql">SHOW CREATE VIEW 视图名称; -- 查询创建视图语句
SELECT * FROM 视图名称...; -- 查询视图数据
</code></pre>
<ul>
<li>修改视图</li>
</ul>
<pre><code class="sql">create [or replace] view 视图名称[(列名列表)] AS SELECT语法 [WITH [CASCADED|LOCAL] CHECK OPTION]; -- 因为有or replace
alter view 视图名称[(列名列表)] as select 语句 [WITH [CASCADED|LOCAL] CHECK OPTION];
</code></pre>
<ul>
<li>删除</li>
</ul>
<pre><code class="sql">drop view [if exists] 视图名称 [,视图名称] ...;
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create or replace view stu_v1_1 as select id,name from student where id &lt;=10;
select * from stu_v1_1 where id = 3;
create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;
alter view stu_v_1 as select id,name,no from student where id &lt;= 10;
</code></pre>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>视图可以基于另一个视图创建</p>
<p>如果直接执行insert语句,其插入到基表中,而非在视图中更新</p>
<p>向视图插入数据时,则需要满足视图的要求(仅启用视图选项时需要遵守要求)</p>
<pre><code class="sql">create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10 with cascaded check option; -- 逐级检查选项,如果此后执行insert语句,若发现与视图的字段不匹配,将阻止插入
</code></pre>
<p>可以增加检查选项cascaded check option来实时更新视图,视图选项默认为cascaded(只有增加视图选项时才可)</p>
<ul>
<li>cascaded</li>
</ul>
<p>如果不加cascaded,进行修改时不受任何影响</p>
<p>如果加上cascaded,修改时会受其影响,要求满足视图的要求</p>
<pre><code class="sql">create view v1 as select id,name from student where id &lt;= 20; -- 可以在v1插入id大于20的数据

create view v2 as select id,name from v2 where id &gt;=10 with cascaded check option; -- 会检查v1和v2的条件,只有两个条件都通过才可执行修改操作
</code></pre>
<p>如:v1无视图选项,v2基于v1,v2为cascaded,v3基于v2,无视图选项,则基表插入数据时会检查v1,v2,不会检查v3</p>
<ul>
<li>local</li>
</ul>
<p>local即只检查当前视图选项,校验过程从v2到v1,判断v1是否有选项,无则跳过,有则校验</p>
<h2 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h2><p>要使视图可更新,视图的行与基础表中行之间必须存在一对一关系.如果包含任何一项,则不可更新(即不可以向视图插入数据):</p>
<p>聚合函数(不是一对一)</p>
<p>DISTINCT(合并了)</p>
<p>GROUP BY(分组,也合并了)</p>
<p>HAVING(基于分组)</p>
<p>UNION <a href="%E5%90%88%E5%B9%B6%E8%A7%86%E5%9B%BE%E4%BA%86">ALL</a></p>
<h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol>
<li>简单</li>
</ol>
<p>视图简化用户对数据的理解,并且简化他们的操作.经常使用的操作定义为视图</p>
<ol start="2">
<li>安全</li>
</ol>
<p>数据库可以授权,但无法授权至指定行与列;通过视图用户只能查询和修改他们所看到的数据</p>
<pre><code class="sql">create user &#39;username&#39;@&#39;host&#39; identified by &#39;password&#39;;
revoke all privileges on database.table from &#39;username&#39;@&#39;host&#39;; -- 避免用户直接操作基表
grant select,insert,update,delete on database.view to &#39;username&#39;@&#39;host&#39;;
flush privileges; -- 刷新权限
</code></pre>
<ol start="3">
<li>数据独立</li>
</ol>
<p>…</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol>
<li>为保证数据库表的安全性,在操作tb_user表时,只能看到用户基本字段,屏蔽手机号和邮箱两个字段</li>
</ol>
<pre><code class="sql">create or replace view tb_user_v_1 as select id,name from tb_user local check option;
revoke all privileges on itcast.tb_user from &#39;username&#39;@&#39;host&#39;;
grant select,update,delete,insert on itcast.tb_user to &#39;username&#39;@&#39;host&#39;;
flush privileges; -- 刷新权限
</code></pre>
<ol start="2">
<li>查询每个学生所选修的课程.为简化操作定义一个视图</li>
</ol>
<pre><code class="sql">create or replace view stu_course_v_1 as select s.id,s.name,c.name from student s, course c, student_course sc where s.id = sc.stu_id and c.id = sc.course_id;
</code></pre>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程是在数据库服务器上执行各种复杂业务逻辑,而<strong>无需多次发送单个SQL查询</strong>.</p>
<p>优点:</p>
<p>性能提升:减少网络交互(最显著优点)</p>
<p>安全</p>
<p>缺点:</p>
<p>调试复杂</p>
<p>版本控制困难</p>
<p>数据库负载增加:把业务逻辑放在数据库服务器中实现,会影响数据库性能</p>
<p>现阶段存储过程一般禁用</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建</p>
<pre><code class="sql">CREATE PROCEDURE 存储过程名称[(参数列表)] -- 相当于函数定义
BEGIN
    SQL语句 -- 所有逻辑都在里面
END;
</code></pre>
<p>调用</p>
<pre><code class="sql">CALL 名称([参数])
</code></pre>
<p>查看</p>
<pre><code class="sql">SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息,xxx填数据库名称(即该数据库中有什么存储过程)
-- INFORMATION_SCHEMA系统自己的数据库,ROUTINES是该数据库自带的表

SHOW CREATE PROCEDURE 存储过程名称; -- 查看某个存储过程定义
</code></pre>
<p>删除</p>
<pre><code class="sql">DROP PROCEDURE [IF EXISTS] 存储过程名称;
</code></pre>
<p>在命令行中,执行创建存储过程的SQL中,需要通过关键字delimiter指定SQL语句的结束符(否则分号会作为存储过程的结尾)</p>
<pre><code class="sql">delimiter $$;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create procedure p1()
begin
    select count(*) from student;
end; -- 在命令行中会报错

call p1();

delimiter $$
create procedure p1()
begin
    select count(*) from student;
end$$ -- 成功执行
delimiter ; -- 恢复分隔符
</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>系统变量: 由MYSQL服务器提供,属于服务器层面;分为全局变量(GLOBAL)与会话变量(SESSION)</p>
<p>查看系统变量</p>
<pre><code class="sql">SHOW [SESSION|GLOBAL] VARIABLES; -- 查看所有系统变量
SHOW [SESSION|GLOBAL] VARIABLES LIKE &#39;...&#39;; -- 通过like可以进行模糊匹配
SELECT @@[SESSION.|GLOBAL.]系统变量名; -- 查看指定变量值
</code></pre>
<p>设置变量值</p>
<pre><code class="sql">SET [SESSION|GLOBAL] 系统变量名 = 值;
SET @@[SESSION.|GLOBAL.]系统变量名 = 值;
</code></pre>
<p>如果没有指定SESSION&#x2F;GLOBAL,默认SESSION</p>
<p>mysql重新启动后,所设置的全局参数会失效,需要在&#x2F;etc&#x2F;my.cnf中配置,则不会失效</p>
<p>示例:</p>
<pre><code class="sql">select @@session.autocommit;
set session autocommit = 0;
</code></pre>
<h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><p>用户根据需要自己定义的变量,无需提前声明,只需@变量名即可.作用域为当前连接</p>
<ul>
<li>赋值</li>
</ul>
<pre><code class="sql">SET @var_name = expr [,@var_name=expr...]; -- 因为比较相等也是用=,容易混淆
SET @var_name := expr ... ; -- 推荐使用这个
select @var_name := expr ...;
select 字段名 into @var_name FROM 表名;
</code></pre>
<ul>
<li>使用</li>
</ul>
<pre><code class="sql">SELECT @var_name;
</code></pre>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">set @myname = &#39;itcast&#39;;
set @myage := 10;
set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;

select @myname,@myage,@mygender,@myhobby;
</code></pre>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>需要DECLARE声明,范围在BEGIN … END块内</p>
<pre><code class="sql">DECLARE 变量名 变量类型 [DEFAULT ...]; -- DEFAULT 指定默认值
</code></pre>
<p>赋值:</p>
<pre><code class="sql">set 变量名:=值; -- 也可=
select field_name into 变量名 from 表名;
</code></pre>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create procedure p2()
begin
    declare stu_count int default 0;
    select count(*) into stu_count from student;
    select stu_count; 
end;

call p2();
</code></pre>
<h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><p>语法:</p>
<pre><code class="sql">IF condition1 THEN

ELSEIF condition2 THEN

ELSE
...
END IF;
</code></pre>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">create procedure p4()
begin
    declare score int default 58;
    declare result varchar(10);
    if score &gt;= 85 then
        set result := &#39;优秀&#39;;
    elseif score &gt;= 60 then
        set result := &#39;及格&#39;;
    else
        set result := &#39;不及格&#39;;
    end if;
end;
</code></pre>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>in: 输入参数</p>
<p>out: 输出参数,也就是可以作为返回值</p>
<p>inout: 既可以作为输入也可以输出</p>
<p>用法:</p>
<pre><code class="sql">create procedure 存储过程名称([in/out/inout] 参数名 参数类型)
begin
    sql语句
end;
</code></pre>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p>根据传入参数score,判定等级并返回</p>
<pre><code class="sql">
create procedure p4(in score int,out result varchar(10)) -- 返回result
begin
    if score &gt;= 85 then
        set result := &#39;优秀&#39;;
    elseif score &gt;= 60 then
        set result := &#39;及格&#39;;
    else
        set result := &#39;不及格&#39;;
    else if;
end;

call p4(68,@result);


create procedure p5(inout score double)
begin
    set score := score * 0.5
end;

set @score = 50;
call p5(@score); -- 会更改@score
select @score
</code></pre>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表有关的数据库对象,即在insert&#x2F;update&#x2F;delete之前或之后触发并执行触发器中定义的SQL语句集合</p>
<p>用于数据库保证数据完整性,日志记录,数据校验等操作</p>
<p>使用OLD或NEW引用触发器中发生变化的记录内容.现触发器还只支持行级触发,不支持语句级触发</p>
<p>触发器类型:</p>
<p>INSERT型触发器:NEW表示将要或已经新增的数据</p>
<p>UPDATE型触发器:OLD表示修改之前数据,NEW表示将要或已修改的数据</p>
<p>DELETE型触发器:OLD表示将要或已经删除的数据</p>
<h2 id="insert触发器"><a href="#insert触发器" class="headerlink" title="insert触发器"></a>insert触发器</h2><p>语法:</p>
<p>创建:</p>
<pre><code class="sql">CREATE TRIGGER trigger_name
BEFORE/AFTER INSERT/UPDATE/DELETE
ON table_name FOR EACH ROW -- 行级触发器
BEGIN
    trigger_stmt;
END;
</code></pre>
<p>查看:</p>
<pre><code class="sql">SHOW TRIGGERS;
</code></pre>
<p>删除触发器:</p>
<pre><code class="sql">DROP TRIGGER [schema_name.]trigger_name; -- 如果出不指定schema_name,默认当前数据库
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ff7d73">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #00a596">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/21/SQL%E5%AD%A6%E4%B9%A0-%E4%B9%9D-%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/20/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96/">
        <h2 class="post-title">SQL学习(八) SQL优化</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>insert优化:</p>
<ol>
<li><p>建议批量插入(一次性插入数据最好500-1000条),若上千条,则分割为多条insert插入</p>
</li>
<li><p>手动提交事务</p>
</li>
</ol>
<pre><code class="sql">start transaction;
insert ...

commit;
</code></pre>
<ol start="3">
<li>主键顺序插入</li>
</ol>
<p>建议顺序插入,而不是乱序插入</p>
<ul>
<li>大批量插入数据</li>
</ul>
<p>如果一次性插入大量数据,不建议使用insert,而是使用load</p>
<pre><code class="bash"># 客户端连接服务端时,加上参数--local-infile用于加载本地文件
mysql --local-infile -u root -p
# 设置全局参数local_infile为1,开启从本地加载文件导入数据的开关
set global local_infile = 1;
# 执行load指令,将数据文件加载至表结构中
load data local infile &#39;/root/sql1.log&#39; into table &#39;rb_user&#39; fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;
</code></pre>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>在InnoDB存储引擎中,表数据根据主键顺序组织存放,即索引组织表(IOP,Index Organized Table)</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空,也可以填充一半,百分百.每个页包含了2-N行数据(如果一行数据过大,会行溢出),根据主键排列</p>
<p><img src="/images/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96-1.png" alt="主键顺序插入"></p>
<p>主键乱序插入时,会出现页分裂情况,具体操作如下:</p>
<p>插入一个已满的页时,将满的页分为两份,第二份放入新的页,并重新调整页与页间的指针</p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>删除一行记录时,并没有实际上被物理删除,只是被标记(flaged)为删除,并且其空间变为允许其他记录声明使用</p>
<p>当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%),InnoDB会开始寻找最靠近的页(前或后)是否可将两个页合并优化空间使用,即页合并</p>
<p>MERGE_THRESHOLD</p>
<h3 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h3><ol>
<li><p>满足业务需求情况下,尽量降低主键长度</p>
</li>
<li><p>插入数据时,尽量顺序插入(乱序插入会出现页分裂问题),选择使用AUTO_INCREMENT自增主键</p>
</li>
<li><p>尽量不要使用UUID或其他自然主键(如身份证),因为长度过长并且无序</p>
</li>
<li><p>业务操作时,尽量避免对主键的修改</p>
</li>
</ol>
<h2 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h2><p>排序方式</p>
<ol>
<li><p>Using filesort: 通过表索引或全表扫描,读取满足条件的数据行,在排序缓冲区sort buffer中完成排序操作, 所有不是通过索引直接返回排序结果的排序都称为FileSort排序</p>
</li>
<li><p>Using index: 通过索引顺序扫描直接返回有序数据,这种是using index,不需要额外排序,操作效率高</p>
</li>
</ol>
<p>即:尽可能覆盖索引,</p>
<pre><code class="sql">-- 没有创建索引时,根据age,phone进行排序(效率低)
explain select id,age,phone from tb_user order by age,phone;
-- 创建索引
create index idx_user_age_phone_aa on tb_user(age,phone);
-- 再升序排
explain select id,age,phone from tb_user order by age,phone;
-- age 降,phone降
explain select id,age,phone from tb_user order by age desc,phone desc;
-- 如果一个升序排,一个降序排,会出现FileSort
explain select id,age,name from tb_user order by age asc, phone desc;
-- 创建索引(根据升降序)
create index idx_user_phone_ad on tb_user(age asc,phone desc); -- 如果不指定asc,desc,默认asc
-- 再进行排序(此时using index)
explain select id,age,name from tb_user order by age asc,phone desc;
</code></pre>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p>根据排序字段建立合适的索引,多字段排序时,遵循最左前缀法则</p>
</li>
<li><p>尽量使用覆盖索引</p>
</li>
<li><p>多字段排序,一个升一个降时,注意联合索引在创建时的规则(ASC&#x2F;DESC)</p>
</li>
<li><p>如果不可避免出现filesort,大数据量排序时,可适当增大排序缓冲区大小sort_buffer_size(默认256k)(若超出缓冲区大小,则会在磁盘文件中排序,效率较低)</p>
</li>
</ol>
<h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><pre><code class="sql">-- 删索引
drop index idx_user_pro_age_sta on tb_user;
-- 执行分组操作,根据profession字段分组
explain select profession,count(*) from tb_user group by profession;
-- 创建索引
create index idx_user_sta on tb_user(profession,age,status)
-- 分组,根据profession字段分组
explain select profession,count(*) from tb_user group by profession; -- 满足最左前缀
-- 根据profession,age分组
explain select profession,count(*) from tb_user group by profession,age; -- 满足最左前缀
explain select profession,count(*) from tb_user group by age; -- 不满足最左前缀
explain select profession,count(*) from tb_user where profession = &#39;软件工程&#39; group by age; -- 满足最左前缀
</code></pre>
<p>当我们执行 group by 操作在没有合适的索引可用的时候，通常先扫描整个表提取数据并创建一个临时表，然后按照 group by 指定的列进行排序。在这个临时表里面，对于每一个 group 的数据行来说是连续在一起的。完成排序之后，就可以发现所有的 groups，并可以执行聚集函数（aggregate function）。可以看到，在没有使用索引的时候，需要创建临时表和排序。在执行计划中通常可以看到“Using temporary; Using filesort”。</p>
<p>在Extra中</p>
<p>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</p>
<p>Using temporary，表示使用了临时表；</p>
<p>Using filesort，表示需要排序。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>满足最左前缀法则,尽可能覆盖索引,避免建立临时表</p>
<h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>在大数据情况下,越往后效率越低,耗时越长,如limit 2000000,10,此时mysql需要对前2000000进行排序,而仅返回需要的10个数据,并丢弃前面的记录,代价巨大</p>
<p>优化思路: 创建 覆盖索引 提升性能,通过覆盖索引和子查询形式进行优化</p>
<pre><code class="sql">explain select * from tb_sku t limit 2000000,10; -- 耗时时间长

select id from tb_sku order by id limit 2000000,10;
explain select * from tb_sku t, (select id from tb_sku order by id limit 2000000, 10) a where t.id = a.id;
explain select * from tb_sku where id in (select id from tb_sku order by id limit 2000000,10);
</code></pre>
<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><pre><code class="sql">explain select count(*) from tb_user;
</code></pre>
<p>MyISAM引擎把一个表总行数存在磁盘中,因此执行count(*)时直接返回该数,效率高</p>
<p>InnoDB需要一行行读出来,累积计数</p>
<p>优化思路:自己计数(自行维护总数,插入时自行加一,删除时自行减一)</p>
<h3 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h3><p>非null计数</p>
<p>count(*),count(字段),count(1)</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>count(主键)</li>
</ul>
<p>InnoDB引擎遍历整张表,把每一行主键id值取出来,返回给服务层,服务层拿到主键后一行行累加(主键不可能为null)</p>
<ul>
<li>count(字段)</li>
</ul>
<p>没有not null约束: InnoDB引擎遍历整张表把每一行字段取出来,返回给服务层,判断是否为null</p>
<p>有not null约束:同count(主键)</p>
<ul>
<li>count(1)</li>
</ul>
<p>InnoDB遍历整张表,但不取值,对于返回的每一行放个’1’进去,直接按行累加</p>
<ul>
<li>count(*)</li>
</ul>
<p>InnoDB引擎并不把全部字段取出,而是优化,不取值,直接进行累加</p>
<p>效率排行: count(字段) &lt; count(主键) &lt; count(1) &#x3D; count(*),所以尽量使用count(*)</p>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><pre><code class="sql">update student set no = &#39;200100100&#39; where id = 1;
update student set no = &#39;2000100105&#39; where name = &#39;韦一笑&#39;;
</code></pre>
<p>InnoDB行锁是针对索引加的锁,而非针对记录加的锁,并且该索引不能失效,否则将从行锁上升到表锁;如果没有索引,也会从行锁上升至表锁</p>
<p>上升至表锁,并发性能将会降低</p>
<p>加锁后,只要事务没有提交,该锁就不会释放</p>
<p>不要让锁上升至表锁,否则所有业务都会停滞</p>
<p>关键还得看这条语句在执行过程中，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #00bcd4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #03a9f4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/20/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AB-SQL%E4%BC%98%E5%8C%96/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95/">
        <h2 class="post-title">SQL学习(七) 存储引擎,索引</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MYSQL体系结构"><a href="#MYSQL体系结构" class="headerlink" title="MYSQL体系结构"></a>MYSQL体系结构</h2><p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-1.png" alt="体系结构图"></p>
<ul>
<li>客户端连接器</li>
</ul>
<p>用于连接mysql服务器</p>
<ul>
<li>连接层</li>
</ul>
<p>连接池,接收客户端连接,进行认证处理(校验密码),权限等,检查是否超过最大连接数</p>
<ul>
<li>服务层</li>
</ul>
<p>核心功能, SQL接口,解析器,查询优化器,缓存</p>
<ul>
<li>可插拔引擎层</li>
</ul>
<p>可插拔:如果需要该存储引擎,则插入;不需要则拔掉,即可插拔</p>
<p>控制数据存储和提取方式</p>
<p>索引是在存储引擎实现的,即:不同引擎索引结构不同</p>
<p>InnoDB是Mysql5.5后默认引擎</p>
<ul>
<li>存储层</li>
</ul>
<p>用于存储数据库相关数据,如日志,系统文件,数据文件</p>
<h2 id="存储引擎-1"><a href="#存储引擎-1" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎即 存储数据,更新&#x2F;查询等技术实现方式.存储引擎是基于<strong>表</strong>的,而不是基于库的,因此存储引擎也可被称为表类型</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>查询建表语句 – 默认InnoDB</p>
<pre><code class="sql">show create table 表;
</code></pre>
<p>查询当前数据库支持的存储引擎</p>
<pre><code class="sql">SHOW ENGINES;
</code></pre>
<p>创建表时,指定存储引擎:</p>
<pre><code class="sql">create table 表名(
    字段名 类型(范围) 约束 comment 注释,
    ... 
)ENGINE = 存储引擎 comment 注释;
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>创建 my_myisam, 并指定MyISAM存储引擎</p>
<pre><code class="sql">create table my_myisam(
    id int,
    name varchar(10)
)engine = MyISAM;
</code></pre>
<p>创建表my_memory,并指定Memory存储引擎</p>
<pre><code class="sql">create table my_memory(
    id int,
    name varchar(10)
)engine = Memory;
</code></pre>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>高可靠性和高性能,MySQL5.5后为默认MySQL存储引擎</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点:"></a>特点:</h4><p>DML操作支持ACID模型,支持<strong>事务</strong></p>
<p><strong>行级锁</strong>,提高并发访问性能</p>
<p>支持<strong>外键</strong>约束,保证数据完整和正确性</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>xxx.idb, xxx为表名,innoDB引擎每张表都会有一个idb文件,存储表结构(frm,sdi),数据和索引</p>
<p>参数:innodb_file_per_table(默认打开,说明每个表独立空间,关闭则共享空间)</p>
<p>命令行:idb2sdi,从idb文件提取表结构</p>
<h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p>TableSpace: 表空间 存储Segment</p>
<p>Segment: 段 存储Extent</p>
<p>Extent: 区 存储Page, 大小固定1M,包含64个page</p>
<p>Page: 页 存储Row,是磁盘操作的最小单元,大小固定16K</p>
<p>Row: 行 存储数据</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL早期引擎</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>不支持事务,不支持外键</p>
<p>支持表锁,不支持行锁</p>
<p>访问速度快</p>
<h4 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h4><p>xxx.sdi: 表结构信息,可直接打开,存储json文件数据</p>
<p>xxx.MYD: 存储数据</p>
<p>xxx.MYI: 存储索引</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>存储在内存中,受到硬件问题,或断电影响,这些表只能作为临时表或缓存使用</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>内存存放(快)</p>
<p>hash索引(默认)</p>
<h4 id="文件-2"><a href="#文件-2" class="headerlink" title="文件:"></a>文件:</h4><p>xxx.sdi(存储表结构,只有这个文件,因为数据都在内存中)</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-2.png" alt="三引擎区别图"></p>
<h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>InnoDB: MySQL默认存储引擎,事务外键行级锁,若应用对事务完整性有较高要求,在并发条件下要求数据一致性,数据除了插入,查询外,还有很多更新删除操作,则选用InnoDB较合适</p>
<p>MyISAM: 若应用是以读或插入为主,而很少有更新或删除操作,对事务完整性要求并不高,则选用MyISAM较合适, 如日志,或评论等 被替代品:MongoDB(nosql)</p>
<p>Memory: 所有数据在内存中,访问速度快,通常用于临时表及缓存.缺陷即对表大小有限制,无法保障数据安全性 被替代品:Redis(nosql)</p>
<h1 id="Linux安装MySQL"><a href="#Linux安装MySQL" class="headerlink" title="Linux安装MySQL"></a>Linux安装MySQL</h1><ol>
<li>准备Linux服务器</li>
</ol>
<p>版本如CentOS7</p>
<ol start="2">
<li>远程连接Linux服务器</li>
</ol>
<p>使用如Final Shell工具</p>
<ol start="3">
<li><p>下载Linux版MySQL安装包</p>
</li>
<li><p>上传至Linux系统</p>
</li>
<li><p>创建目录,解压</p>
</li>
<li><p>安装mysql安装包(注意安装顺序)</p>
</li>
<li><p>启动SQL服务</p>
</li>
</ol>
<pre><code class="bash">systemctl start mysqld
systemctl restart mysqld
systemctl stop mysqld
</code></pre>
<ol start="8">
<li>查询自动生成的root用户密码</li>
</ol>
<pre><code class="bash">grep &#39;temporary password&#39; /var/log/mysqld.log
</code></pre>
<ol start="9">
<li>设定密码</li>
</ol>
<p>Linux下有密码校验,密码不能太简单,可以设置密码校验策略</p>
<pre><code class="sql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;1234&#39;; -- 修改root密码
</code></pre>
<pre><code class="sql">set global validate_password.policy = 0; -- 设置密码校验强度,0表最弱,1表最强
set global validate_password.length = 4; -- 设置密码长度
</code></pre>
<ol start="10">
<li>创建用户</li>
</ol>
<pre><code class="sql">create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;1234&#39;; -- 用于远程访问
</code></pre>
<ol start="11">
<li>防火墙</li>
</ol>
<p>防火墙开放相应端口,否则可能无法远程连接</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是帮助MySQL高效获取数据的数据结构(有序),在数据之外,数据库系统维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据.这种数据结构即为索引</p>
<p>优点:</p>
<p>加快数据检索效率,降低IO成本;通过索引进行排序,降低CPU效率</p>
<p>缺点:</p>
<p>索引列占用空间(磁盘便宜);降低更新表的速度(增删改频率低)</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>B+Tree索引: 最常见所有,大部分引擎支持B+树索引</p>
<p>Hash索引: 底层数据结构由哈希表实现,只有精确匹配索引列查询时有效,不支持范围查询</p>
<p>R-tree(空间索引): MyISAM引擎的特殊索引类型,主要用于地理空间数据类型,使用较少</p>
<p>Full-text(全文索引): 通过建立倒排索引,快速匹配文档的方式,类似于Lucene,Solr,ES(将文本分词后记录每个词出现在哪篇文本中,用于文本检索)</p>
<p>B+Tree: 三者均支持</p>
<p>Hash 索引: 仅Memory支持</p>
<p>R-tree: 仅MyISAM支持</p>
<p>Full-text: InnoDB 5.6后支持,MyISAM支持</p>
<p>一般指的索引均是B+树结构组织的索引</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>二叉树弊端: 顺序插入时,会退化为链表,查询性能大大降低,大数据量情况下,层级较深,检索速度慢(需要平衡)</p>
<p>解决方案: 红黑树(解决平衡问题)</p>
<p>红黑树问题: 因为是二叉树,层级较深,检索速度慢</p>
<p>B-Tree(多路平衡查找树)</p>
<p>以最大度数5的b树为例(一个节点下四个key(自身),5个指针(指向5个子节点))</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-3.png" alt="B树图例"></p>
<p>当一个节点大于key数时,该节点中间元素向上分裂</p>
<p>B+树:</p>
<p>所有元素均会出现底层叶子节点中(上层的节点用于索引作用),下层形成单向链表,提高插入元素的效率</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-4.png" alt="B+树图例"></p>
<p>mysql进行了优化,下层为双向循环链表</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-5.png" alt="b+树mysql优化图例"></p>
<p>key值和指针的大小为一个页大小,即16K,因为B+树叶子不存储数据,能够存放的东西变多了,层级变少</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>采用一定hash算法,键值转化为新的hash值,对应到相应槽位中,存储到hash表中</p>
<p>hash冲突(hash碰撞):两个或多个值落于相同槽位上;可以通过链表解决</p>
<p>hash索引特点:</p>
<ol>
<li><p>只能用于对等匹配(&#x3D;,in), 不支持范围查询(between,&gt;,&lt;,…)</p>
</li>
<li><p>无法利用索引完成排序操作</p>
</li>
<li><p>查询效率,通常一次检索即可(不出现哈希碰撞情况下),效率通常高于B+树</p>
</li>
</ol>
<p>存储引擎支持:</p>
<p>Memory引擎支持.InnoDB具有自适应hash功能,hash索引是存储引擎根据B+树索引在指定条件下自动构建的.</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么InnoDB存储引擎使用B+tree呢?</p>
<p>相对于二叉树,层级更少,搜索效率高</p>
<p>对于B树,节点都会保存数据,导致一页中存储键值减少,指针减少.要同样保存大量数据,只能增加树的高度,导致性能降低</p>
<p>相对于哈希索引(只支持等值匹配),B+tree支持范围匹配</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建,只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列值重复</td>
<td>(创建唯一字段时自动创建)可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找文本中关键词,而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>根据索引存储形式,分为以下两种:</p>
<p>聚集索引(clustered Index): 数据存储和索引放在一块, 索引结构和叶子节点保存了行数据 必须有且只有一个</p>
<p>二级索引(Secondary Index): 将数据和索引分开存储,索引结构的叶子节点关联的是对应主键 可以存在多个</p>
<p>聚集索引选取规则:</p>
<p>如果存在主键,主键索引就是聚集索引</p>
<p>若不存在主键,将使用唯一索引作为聚集索引</p>
<p>如果表没有主键,或没有合适的唯一索引,则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-6.png" alt="聚集索引图例"></p>
<p>每个叶子节点都保存行数据</p>
<p><img src="/images/sql%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95-7.png" alt="二级索引图例"></p>
<p>二级索引每个叶子存储唯一索引</p>
<p>当执行select * from user where name &#x3D; ‘arm’时,首先从二级索引找到arm,然后通过唯一索引找到行数据,并返回</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol>
<li>效率问题</li>
</ol>
<p>select * from user where id &#x3D; 10;</p>
<p>与</p>
<p>select * from user where name &#x3D; ‘Arm’;</p>
<p>前者效率更高,因为前者只需要进行聚集索引的查找,而后者需要先通过二级索引,再通过聚集索引查找(后者称为<strong>回表查询</strong>)</p>
<ol start="2">
<li>B+树高度问题</li>
</ol>
<p>假设一行数据1k大小,一页则可以存储16个这样的数据;InnoDB指针占用6字节空间,主键设为BigInt,占用空间为8字节</p>
<p>当高度为2时,根节点一个<br>设n为主键个数,一个节点为一页大小,则</p>
<p>8<em>n+6(n+1) &#x3D; 16</em>1024</p>
<p>则n&#x3D;1170,则一个节点指针个数为1171,一个叶子节点有16个数据,则数据量为16*1171 &#x3D; 18736个</p>
<p>若树高度为3,则18736*1171 &#x3D; 21939856个数据</p>
<h2 id="索引操作语法"><a href="#索引操作语法" class="headerlink" title="索引操作语法"></a>索引操作语法</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li>创建索引</li>
</ul>
<pre><code class="sql">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...); -- 若不指定UNIQUE,FULLTEXT,则为常规索引
</code></pre>
<p>如果一个索引仅关联一个字段,则称为单列索引</p>
<p>如果一个索引关联多个字段,则成为联合索引|组合索引</p>
<ul>
<li>查看索引</li>
</ul>
<pre><code class="sql">SHOW INDEX FROM table_name;
</code></pre>
<ul>
<li>删除索引</li>
</ul>
<pre><code class="sql">DROP INDEX index_name ON table_name;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p>name字段姓名字段,该字段值可能会重复,为该字段创建索引</p>
</li>
<li><p>phone手机号字段值,非空唯一,创建唯一索引</p>
</li>
<li><p>为profession,age,status创建联合索引</p>
</li>
<li><p>为email建立合适的索引提高查询效率</p>
</li>
</ol>
<pre><code class="sql">create index idx_user_name on tb_user(name);
create unique index idx_phone on tb_user(phone);
create index idx_profession_age_status on tb_user(profession,age,status);
create index idx_email on tb_user(email);
</code></pre>
<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="查询操作次数"><a href="#查询操作次数" class="headerlink" title="查询操作次数"></a>查询操作次数</h3><ul>
<li>SQL执行频率</li>
</ul>
<p>MYSQL客户端连接成功后,通过show [session|global] status提供服务端状态信息,查看当前数据库INSERT,UPDATE,DELETE,SELECT访问频次</p>
<pre><code class="sql">show global status like &#39;com_______&#39; -- like后面表示需要查询的操作
</code></pre>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数(long_query_time,s,默认10s)的所有SQL语句的日志</p>
<p>MySQL慢查询日志默认未开启,需要在MySQL配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息:</p>
<pre><code class="bash"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志时间为2s,SQL语句执行时间超过2s,则视为慢查询,记录慢查询日志
long_query_time = 2
</code></pre>
<ul>
<li>查询变量</li>
</ul>
<pre><code class="sql">show variables like &#39;slow_query_log&#39; -- 查看慢查询日志是否开启
</code></pre>
<p>慢查询日志位置: &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost_slow.log</p>
<h3 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h3><p>show profiles能够在优化SQL时帮助了解时间消耗,通过have_profiling参数,查看系统是否支持profile操作</p>
<pre><code class="sql">SELECT @@have_profiling; -- 查看是否支持
</code></pre>
<p>默认profiling关闭,可以通过SET语句在session&#x2F;global级别开启profiling</p>
<pre><code class="sql">select @@profiling; -- 查询是否开启
SET [SESSION|GLOBAL] profiling = 1; 
show profile; -- 查看操作时所消耗的时间
</code></pre>
<ul>
<li>查询指定query_id的SQL语句各个阶段耗时情况</li>
</ul>
<pre><code class="sql">show profile for query query_id;
</code></pre>
<ul>
<li>查看指定query_id的SQL语句CPU使用情况</li>
</ul>
<pre><code class="sql">show profile cpu for query query_id;
</code></pre>
<h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>EXPLAIN或DESC命令获取MYSQL如何执行SELECT语句信息,包括SELECT语句执行过程中表如何连接和链接的顺序</p>
<pre><code class="sql">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件; -- 直接在前面加EXPLAIN/DESC即可
</code></pre>
<h4 id="各字段含义"><a href="#各字段含义" class="headerlink" title="各字段含义"></a>各字段含义</h4><ul>
<li>id</li>
</ul>
<p>select查询的序列号,表查询中执行select子句或操作表的顺序(id越大,越先执行;id相同,从上至下执行)</p>
<ul>
<li>select_type</li>
</ul>
<p>表select类型</p>
<p>SIMPLE: 简单表,即不使用表连接或子查询</p>
<p>PRIMARY: 主查询,即外层的查询</p>
<p>UNION: UNION中的第二个或后面的查询语句</p>
<p>SUBQUERY: SELECT&#x2F;WHERE之后包含了子查询</p>
<ul>
<li>type</li>
</ul>
<p>表示连接类型,性能由好到差为: NULL,system,const,eq_ref,ref,range,index,all.</p>
<p>业务系统中不太可能出现NULL(因为NULL是在不访问任何表时出现),尽量向前优化即可</p>
<p>system基本是访问系统表时出现</p>
<p>const在访问主键或唯一索引时会出现</p>
<p>ref在非唯一索引访问时会出现(回表查询)</p>
<p>index是扫描了全部索引</p>
<p>all代表全表扫描,性能最差</p>
<pre><code class="sql">select &#39;A&#39;; -- NULL
</code></pre>
<ul>
<li>possible_key</li>
</ul>
<p>显示可能应用在这张表上的索引,一个或多个</p>
<ul>
<li>key</li>
</ul>
<p>实际用到的索引,若NULL,则没有使用索引</p>
<ul>
<li>key_len</li>
</ul>
<p>表索引中使用的字节数,该值表示索引字段最大可能长度,并非实际使用长度,在不损失精确性前提下,长度越短越好;关注,用于查明是否在检索时使用了相关的索引</p>
<ul>
<li>ref</li>
</ul>
<p>哪些列或者常量被用做索引列上的值</p>
<ul>
<li>rows</li>
</ul>
<p>MySQL认为必须要执行查询的行数,在InnoDB引擎表中,是一个估计值(仅作参考)</p>
<ul>
<li>filtered</li>
</ul>
<p>表示返回结果行数占需读取行数的百分比,filtered的值越大越好(即有效的查询量)</p>
<ul>
<li>Extra</li>
</ul>
<p>附加信息</p>
<h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h3><p>未建立索引前,执行如下SQL语句,查看SQL的耗时</p>
<pre><code class="sql">SELECT * FROM table_name where name = &quot;xxx&quot;; -- 进行查询
</code></pre>
<p>针对字段创建索引</p>
<pre><code class="sql">create [UNIQUE|FULLTEXT] index idx_name on table_name(field_name);
</code></pre>
<p>再次指向相同SQL语句,查看SQL耗时</p>
<h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>针对联合索引. 要求遵循最左前缀法则</p>
<p>最左前缀法则: 查询从索引最左列开始,并且不能跳过索引中的列,<strong>在查询时必须包括最左侧的列,否则将不会走索引</strong></p>
<p>若跳过了某一列,则索引将部分失效(后面的字段索引失效)</p>
<p>即要求最左列必须存在,否则将跳过某一列(即最左列要表明右侧均存在)</p>
<p>如</p>
<pre><code class="sql">create index idx_a_b_c on test(a,b,c);
</code></pre>
<pre><code class="sql">select * from test where a = &#39;aa&#39;; -- 满足最左前缀法则,ref
select * from test where a = &#39;a&#39; and b = &#39;b&#39; and c = &#39;c&#39; ; -- 满足最左前缀法则,ref
select * from test where b = &#39;b&#39; ;-- 不满足最左前缀法则,全表扫描,索引没有生效
select * from test where a=&#39;a&#39; and c = &#39;c&#39;; -- 索引部分失效,前面满足最左前缀法则,索引生效,中间跳过了b,后面索引失效
select * from test where c = &#39;c&#39; and b = &#39;b&#39; and a = &#39;a&#39;; -- 索引生效,只需要存在即可满足最左前缀法则,不需要关注顺序
</code></pre>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>联合索引中,出现范围查询(&gt;,&lt;),范围查询右侧的列索引失效,如:</p>
<pre><code class="sql">explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status = &#39;0&#39;; -- key_len 49,说明status没有使用索引,因为范围查询右侧不走索引
explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 and status = &#39;0&#39;; -- key_len 54,说明status使用索引,因此尽可能使用&gt;=这样的运算符
</code></pre>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol>
<li>索引列运算</li>
</ol>
<p>不要在索引列上进行运算,否则索引将失效</p>
<p>如:</p>
<pre><code class="sql">select * from tb_user where substring(phone,10,2) = &#39;15&#39;; -- 在索引列上进行计算,将进行全表查询,type ALL, like &quot;%15&quot;也同样(因为第一个是%,头部模糊匹配,全表)
</code></pre>
<ol start="2">
<li>字符串不加单引号,隐式类型转换</li>
</ol>
<p>字符串字段使用时,必须要加单引号,不然索引失效(因为隐式转换相当于调用函数)</p>
<ol start="3">
<li>模糊查询</li>
</ol>
<p>若仅仅尾部模糊匹配,则索引不会失效;若头部模糊匹配,索引将会失效</p>
<p>‘%12’ 头部模糊查询失效</p>
<p>‘软件%’ 尾部查询,索引不失效</p>
<ol start="4">
<li>or连接的条件</li>
</ol>
<p>若or一侧有索引,一侧没有索引(或不满足最左前缀原则),不生效,只有两侧都有索引才生效(因为有一个没有索引,就会走全表扫描,为了高效,就不必走索引了)</p>
<p>解决方案: 对于没有索引的建立索引</p>
<ol start="5">
<li>数据分布影响</li>
</ol>
<p>如果MySQL评估发现比全表扫描还慢时,就会直接全表扫描</p>
<p>原因:若几乎所有表内数据基本符合查询条件,则直接全表扫描,不会走索引,提高效率</p>
<h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><p>在SQL语句中加入一些认为的提示来达到优化操作的目的</p>
<p>use index:</p>
<pre><code class="sql">explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL去用这个索引
</code></pre>
<p>当sql评估使用该索引速度较慢时,则不会使用该索引</p>
<p>ignore index:</p>
<pre><code class="sql">explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL不要使用该索引
</code></pre>
<p>force index:</p>
<pre><code class="sql">explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;; -- 提示SQL必须使用该索引
</code></pre>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>主要针对select后的字段部分</p>
<p>尽量使用覆盖索引(查询使用索引,并需要返回的列,在该索引中已经全部能够找到),减少使用select *</p>
<p>using index condition: 查找使用了索引,但是需要回表查询(性能较低)</p>
<p>using where,using index: 查找使用索引,但需要的数据都在索引列中能够找到,不需要回表查询(性能高)</p>
<pre><code class="sql">explain select id,profession from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;;
explain select id,profession,age,status from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;; -- using where ,using index
explain select id,profession,age,status,name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;; -- using index condition
explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39;;
</code></pre>
<p>思考:</p>
<p>一张表四个字段(id,username,password,status),由于数据量大,需要对以下SQL语句优化,如何优化?</p>
<pre><code class="sql">select id,username,password from tb_user where username = &#39;itcast&#39;;
</code></pre>
<p>解决方案:</p>
<p>建立联合索引,则不需要回表查询</p>
<pre><code class="sql">create index idx_username_password on tb_user(username,password);
select id,username,password from tb_user where username = &#39;itcast&#39;;
</code></pre>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串时,有时需要索引很长的字符串,会使得索引变得很大;查询时,浪费大量磁盘IO,影响查询效率.此时可以只将字符串一部分前缀建立索引,大大节约索引空间提升效率</p>
<p>语法:</p>
<pre><code class="sql">create index idx_xxx on table_name(column(n)); -- n表前缀的字符串长度
</code></pre>
<p>前缀长度:</p>
<p>可以根据索引的选择性决定</p>
<p>(选择性指不重复的索引值(基数)和数据表记录总数的比值,索引选择性越高则查询效率越高,唯一索引选择性为1,最好的索引选择性,性能也最好)</p>
<p>选择性 &#x3D; 不重复索引值 &#x2F; 总数</p>
<pre><code class="sql">select count(distinct email) / count(*) from tb_user; -- 获取选择性
select count(distinct substring(email,1,5)) / count(*) from tb_user -- 获取选取一定字串后的选择性
</code></pre>
<h3 id="单列索引与联合索引的选择"><a href="#单列索引与联合索引的选择" class="headerlink" title="单列索引与联合索引的选择"></a>单列索引与联合索引的选择</h3><p>在业务场景中,如果存在多个查询条件,若针对于查询字段建立索引时,建议建立联合索引,而非单列索引</p>
<p>多个联合查询时,MySQL优化器会评估哪个字段的索引效率更高,并选择该索引完成查询</p>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ol>
<li><p>针对数据量较大,且查询比较频繁的表建立索引</p>
</li>
<li><p>针对常作为查询条件(where,order by,group by)建立索引</p>
</li>
<li><p>选择区分度高的列作为索引,尽量建立唯一索引.区分度越高,使用索引效率越高</p>
</li>
<li><p>若字符串类型,字段长度较长,建立前缀索引(通过计算选择性)</p>
</li>
<li><p>尽量选择联合索引,减少单列索引,查询时,联合索引可以覆盖单列索引,节省空间,避免回表</p>
</li>
<li><p>索引并非多多益善,索引越多,维护索引结构代价巨大,会影响增删改的效率</p>
</li>
<li><p>若索引列不能存储null时,创建表时用not null约束.当优化器知道每列是否包含NULL值时,可以更好确定哪个索引最有效用于查询</p>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ffa2c4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ff7d73">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AD-%E4%BA%8B%E5%8A%A1/">
        <h2 class="post-title">SQL学习(六) 事务</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一组操作的集合,不可分割.事务会将一组操作作为整体进行向系统提交或撤销请求.</p>
<p>这些操作同时成功,或同时失败</p>
<p>默认MYSQL的事务是自动提交的,当每执行一条DML语句,便隐式地提交事务</p>
<p>每一个sql语句都是事务</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>操作方式:</p>
<p>将事务提交改为手动提交,在完成一些操作后,如果正常运行,则进行commit提交,如果出错,进行回滚操作</p>
<ul>
<li>查看&#x2F;设置事务提交方式:</li>
</ul>
<pre><code class="sql">SELECT @@autocommit;
SET @@autocommit = 0;
</code></pre>
<ul>
<li>提交事务</li>
</ul>
<pre><code class="sql">COMMIT;
</code></pre>
<ul>
<li>回滚事务</li>
</ul>
<pre><code class="sql">ROLLBACK;
</code></pre>
<ul>
<li>开启事务</li>
</ul>
<pre><code class="sql">START TRANSACTION 或 BEGIN;
</code></pre>
<ul>
<li>提交事务</li>
</ul>
<pre><code class="sql">COMMIT
</code></pre>
<ul>
<li>回滚事务</li>
</ul>
<pre><code class="sql">ROLLBACK;
</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>完成转账操作:张三给李四转1000(自动提交事务)</p>
<pre><code class="sql">select * from account where name = &#39;张三&#39;;
update account set money = money - 1 where name = &#39;张三&#39;;
update account set money = money + 1 where name = &#39;李四&#39;;
</code></pre>
<p>手动提交事务(方式一)</p>
<pre><code class="sql">set @autocommit = 0; -- 设置为手动提交
select * from account where name = &#39;张三&#39;;
update account set money = money - 1 where name = &#39;张三&#39;;
update account set money = money + 1 where name = &#39;李四&#39;;
-- 此时数据并未更新
commit; -- 提交事务,如果途中出错,则不会允许到commit,也就不会执行出错前的结果.

rollback; -- 回滚事务,把之前操作取消了(因为如果出错的话,则原来的操作结果会在缓存内,如果不进行回滚,当执行其他语句时,这些缓存的操作结果会影响数据,因此必须回滚)
</code></pre>
<p>方式二</p>
<pre><code class="sql">set @@autocommit = 1
start transaction;
select * from account where name = &#39;张三&#39;;
update account set money = money - 1 where name = &#39;张三&#39;;
update account set money = money + 1 where name = &#39;李四&#39;;

commit; -- 如果没有异常
rollback; -- 如果出现异常
</code></pre>
<h3 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h3><ul>
<li><p>原子性(Atomicity): 事务不可分割最小单元, 要么全部成功,要么全部失败</p>
</li>
<li><p>一致性(Consistency): 事务完成时,必须使所有数据保持一致状态</p>
</li>
<li><p>隔离性(Isolation): 数据库提供隔离机制,保证事务不受外部并发操作影响</p>
</li>
<li><p>持久性(Durability): 事务一旦提交或回滚,则它对数据库数据改变是永久的</p>
</li>
</ul>
<h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>问题如下:</p>
<ol>
<li><p>脏读: 一个事务读到另一个事务还没有提交的数据(如果那个事务失败了,则会出现问题)</p>
</li>
<li><p>不可重复读: 一个事务先后读取同一条记录,但两次读取数据不同(数据在两次读取期间被改了)</p>
</li>
<li><p>幻读: 一个事务按照条件查询数据时,没有对应数据行,但插入数据时,又发现这条数据已经存在,好像出现幻影(即查询时数据未存在,而到插入数据之前,数据被插入到表中)</p>
</li>
</ol>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>√ 表示会出现问题</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted()</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>x</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>x</td>
<td>x</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>从上至下性能下降</p>
<pre><code class="sql">-- 查看事务隔离级别
SELECT @@TRANSACTION_ISOLATION; 
-- 设置事务隔离级别(SESSION表当前会话,即当前客户端窗口,GLOBAL全局)
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE];
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #00a596">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #ffa2c4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/18/SQL%E5%AD%A6%E4%B9%A0-%E5%85%AD-%E4%BA%8B%E5%8A%A1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/17/SQL%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">
        <h2 class="post-title">SQL学习(五) 多表查询</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/17
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>属于data query language</p>
<h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p>多个表关系:</p>
<p>一对多(多对一)</p>
<p>多对多</p>
<p>一对一</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例:部门与员工关系</p>
<p>关系:一:部门 多:员工</p>
<p>实现:多的一方建立外键,指向一的一方</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例:学生与课程关系</p>
<p>关系: 多:学生 多:课程</p>
<p>实现:</p>
<p>建立一张中间表,至少包含两个外键,分别关联两方主键</p>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例: 用户与用户详情的关系</p>
<p>关系: 一对一关系,多用于单表拆分,将基础字段放在一张表中,详情字段放在另一张中,以提升操作效率</p>
<p>实现:</p>
<p>在任意一方加入外键,关联另一方主键,设置外键为唯一的(UNIQUE)</p>
<p>多表查询:</p>
<p>从多表中查询数据</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h4><ul>
<li>连接查询<ul>
<li>内连接:查询A,B交集部分数据</li>
<li>外连接:<ul>
<li>左外连接: 查询左表所有数据,以及两表交集</li>
<li>右外连接: 查询右表所有数据,以及交集</li>
</ul>
</li>
<li>自连接: 当前表与自身连接查询,子链接必须使用表别名</li>
</ul>
</li>
<li>子查询</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>设有emp表10个数据,dept表5个数据</p>
<pre><code class="sql">select * from emp,dept; -- 多表查询,会得到10*5=50条数据,每一个对应进行穷举得到,即笛卡尔积,即A集合与B集合所有组合情况

select * from emp,dept where emp.dept_id = dept.id;
</code></pre>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询交集部分</p>
<p>隐式内连接</p>
<pre><code class="sql">SELECT 字段列表 FROM 表1,表2 WHERE 条件;
</code></pre>
<p>显式内连接</p>
<pre><code class="sql">SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;
</code></pre>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询每一个员工姓名以及关联部门名称</li>
</ol>
<pre><code class="sql">select emp.name,dept.name from emp,dept where emp.dept_id = dept.id;-- 隐式内连接
select e.name,d.name from emp e,dept d where e.dept_id = d.id; -- 如果为表起了别名,则不可以使用原名

select emp.name,dept.name from emp e inner join dept d on e.dept_id = d.id; -- 显式外连接
</code></pre>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>包含一张表所有内容以及交集部分</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT field_list FROM table1 LEFT [OUTER] JOIN table2 ON condition...; -- 左外连接

SELECT field_list FROM table1 RIGHT [OUTER] JOIN table2 ON condition...; -- 右外连接
</code></pre>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>查询emp表所有数据和相对应部门信息</p>
<pre><code class="sql">select e.*, d.name from emp e left outer join dept d on e.dept = d.id; -- 左外查询(包含未分配部门的信息)

select e.*,d.name from emp e right outer join dept d on e.dept = d.id; -- 右外查询(包含未分配员工的部门的信息)
</code></pre>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT field_list FROM tableA aliasA [INNER] JOIN tableA aliasB ON condition;

SELECT field_list FROM tableA aliasA,tableA aliasB WHERE condition;
SELECT field_list FROM tableA aliasA RIGHT|LEFT [OUTER] JOIN tableA aliasB ON condition...
</code></pre>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>自连接既可以使用内连接,也可以使用外连接</p>
<p>自连接时,把一张表看作是两张表</p>
<p>如果查询内容出现null值,则需要使用外连接</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ol>
<li>查询员工及其编号所属领导名字</li>
</ol>
<pre><code class="sql">select e.name,m.name from emp e inner join emp m on e.manager_id = m.id;
</code></pre>
<ol start="2">
<li>查询所有员工信息及其领导名字emp,若员工没有领导,也需要查询</li>
</ol>
<p>需要外连接</p>
<pre><code class="sql">select e.name &#39;员工&#39;,m.name &#39;领导&#39; from emp e left outer join emp m on e.manager_id = m.id;
</code></pre>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>即把多次查询结果合并起来,形成一个新的查询结果</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT field_list FROM tableA ... -- 没有分号!
UNION [ALL]
SELECT field_list FROM tableB...; -- 这三行是一个语句!
</code></pre>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>union all: 直接将查询结果合并(会出现重复)</p>
<p>union: 去重</p>
<p>使用条件: 联合查询多张表的列数必须一致,字段类型也必须一致</p>
<p>如:</p>
<pre><code class="sql">select * from emp where salary &gt; 1
union
select name from emp where age &lt; 50; -- ERROR!字段不一致!
</code></pre>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>将薪资低于5000的员工,和年龄大于50的员工查询出来(或逻辑)</p>
<pre><code class="sql">select * from emp where salary &lt; 5000
union all
select * from emp where age &gt;50;
</code></pre>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL 语句中嵌套SELECT语句,又称嵌套查询</p>
<p>分类:</p>
<ul>
<li>标量子查询 子查询结果为单个值</li>
<li>列子查询 结果一个列</li>
<li>行子查询 一个行</li>
<li>表子查询 多行多列</li>
</ul>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</code></pre>
<p>外部语句可以是 INSERT|UPDATE|DELETE|SELECT, DQL,DML</p>
<p>位置可以是WHERE|FROM|SELECT</p>
<p>标量子查询: 常用&gt; &lt; &#x3D; &gt;&#x3D; &lt;&#x3D;</p>
<p>列子查询:常用 IN(在指定集合内) NOT IN ANY(子查询返回的列表中,任意一个满足即可) SOME(同ANY) ALL(必须全部满足)</p>
<p>行子查询: 常用&#x3D; !&#x3D; IN NOT IN</p>
<p>表子查询: 常用IN</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><ul>
<li>标量子查询</li>
</ul>
<p>查询销售部所有员工信息</p>
<pre><code class="sql">select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);
</code></pre>
<p>查询”方东白”入职后员工信息</p>
<pre><code class="sql">select * from emp where entry_date &gt; (select entry_date from emp where name = &#39;方东白&#39;);
</code></pre>
<ul>
<li>列子查询</li>
</ul>
<ol>
<li>查询”销售部”和”市场部”的所有员工信息</li>
</ol>
<pre><code class="sql">select * from emp where dept in (select id from dept where name in (&#39;销售部&#39;,&#39;市场部&#39;));
</code></pre>
<ol start="2">
<li>查询比财务部所有人工资都高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp where salary &gt; all(select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;)) -- where比聚合函数先执行
</code></pre>
<ol start="3">
<li>查询比研发部任意一人工资都高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp where salary &gt; any(select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;));
</code></pre>
<ul>
<li>行子查询</li>
</ul>
<p>查询与”张无忌”的薪资及其直属领导 相同的员工信息</p>
<pre><code class="sql">select * from emp where salary = (select salary from emp where name = &#39;张无忌&#39;) and manager_id = (select id from emp where name = &#39;张无忌&#39;);

select * from emp where (salary,manager_id) = (select salary,id from emp where name = &#39;张无忌&#39;);
</code></pre>
<ul>
<li>表子查询</li>
</ul>
<ol>
<li>查询与”a”,”b”的职位与薪资相同的员工信息</li>
</ol>
<pre><code class="sql">select * from emp where (dept_id,salary) in (select dept_id,salary from emp where name in(&#39;a&#39;,&#39;b&#39;));
</code></pre>
<ol start="2">
<li>查询入职日期为’2006-01-01’之后员工信息及其部门信息</li>
</ol>
<pre><code class="sql">select e.*,d.* from (select * from emp where entry_date &gt; &#39;2006-01-01&#39;) e left join dept d on d.id = e.dept_id; -- select后也可以直接写*
</code></pre>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol>
<li>查询员工姓名,年龄,职位,部门信息(隐式内连接)</li>
</ol>
<pre><code class="sql">select e.name,e.age,e.position,d.name from emp e, dept d where d.id = e.dept_id;
</code></pre>
<ol start="2">
<li>查询年龄小于30岁员工姓名,年龄,职位,部门信息(显式内连接)</li>
</ol>
<pre><code class="sql">select e.name,e.age,e.position,d.name from emp e inner join dept d where e.age&lt;30 on e.dept_id = d.id; 
</code></pre>
<ol start="3">
<li>查询拥有员工的部门(id,名称)</li>
</ol>
<pre><code class="sql">select distinct d.* from emp e join dept d on e.dept_id = d.id;
</code></pre>
<ol start="4">
<li>查询所有年龄大于40岁的员工,及其归属部门名称,如果员工没有分配部门,也需要展示</li>
</ol>
<pre><code class="sql">select e.*,d.name from emp e left join dept d on e.dept_id = d.id where e.age&gt;40;
</code></pre>
<ol start="5">
<li>查询所有员工工资等级</li>
</ol>
<p>设有sal_grade表,有losal和hisal(分别是最低工资与最高工资)两列,有grade表示薪资水平</p>
<pre><code class="sql">select e.name,s.grade from emp e, salary s where e.salary between s.losal and s.hisal;
</code></pre>
<ol start="6">
<li>查询 “研发部” 所有员工信息及工资等级</li>
</ol>
<pre><code class="sql">select e.*,s.grade from emp e,salary s where e.dept_id = (select id from dept where name = &#39;研发部&#39;) and e.salary between s.losal and s.hisal;
</code></pre>
<ol start="7">
<li>查询 “研发部” 平均工资</li>
</ol>
<pre><code class="sql">select avg(e.salary) from emp e where e.dept_id = (select id from dept where name = &#39;研发部&#39;);

select avg(e.salary) from emp e,dept,d where e.dept_id = d.id and d.name = &#39;研发部&#39;;
</code></pre>
<ol start="8">
<li>查询工资比 ‘a’ 高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp e where e.salary &gt; (select salary from emp where name = &#39;a&#39;);
</code></pre>
<ol start="9">
<li>查询比平均薪资高的员工信息</li>
</ol>
<pre><code class="sql">select * from emp e where e.salary &gt; (select avg(salary) from emp);
</code></pre>
<ol start="10">
<li>查询比本部门平均薪资低的员工信息</li>
</ol>
<pre><code class="sql">select * from emp e1 where e1.salary &lt;(select avg(salary) from emp e2 where e1.dept_id = e2.dept_id);
</code></pre>
<ol start="11">
<li>查询所有部门信息并统计部门的员工人数</li>
</ol>
<pre><code class="sql">select d.*,(select count(*) from emp e where e.dept_id = d.id) &#39;人数&#39; from dept d;
</code></pre>
<ol start="12">
<li>查询所有学生选课情况,显示出学生名称,学号,课程名称</li>
</ol>
<p>表: student, course, student_course</p>
<p>连接条件: student.id &#x3D; student_course.student_id, course.id &#x3D; student_course.course_id</p>
<pre><code class="sql">select s.name,s.number,c.name from student s, student_course sc , course c where sc.student_id = s.id and sc.course_id = course.id;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #03a9f4">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #00bcd4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/17/SQL%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/09/16/SQL%E5%AD%A6%E4%B9%A0-%E5%9B%9B/">
        <h2 class="post-title">SQL学习(四)</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/9/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>作用于字段上的规则,限制存储于表中的数据</p>
<pre><code class="sql">NOT NULL -- 非空约束
UNIQUE -- 唯一约束 所有数据均唯一
PRIMARY KEY -- 主键约束 主键是一行数据的唯一标识,非空且唯一
DEFAULT -- 默认约束,如果保存数据时,未指定该字段的值,则采用默认值
CHECK -- 检查约束,8.0.16版本后,保证字段满足某条件
FOREIGN KEY -- 外键约束, 让两张表建立起连接,保证数据一致性
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>需求:<br>id ID唯一标识 name 非空唯一 age 大于0且小于120 status 若不指定,默认1 gender 无</p>
<pre><code class="sql">create table user(
    id int primary key auto_increment comment &#39;主键&#39;, -- auto_increment 自动增长
    name varchar(10) unique not null comment &#39;姓名&#39;,
    age tinyint check (age&gt;0 and age&lt;120) comment &#39;年龄&#39;,
    status char(1) default &#39;1&#39; comment &#39;状态&#39;,
    gender char(1)
)comment &#39;用户表&#39;;

insert into user(name,age,status,gender) values (&#39;Tom&#39;,10,&#39;2&#39;,&#39;男&#39;);
insert into user(name,age,status,gender) values (&#39;Tom&#39;,10,null,&#39;男&#39;);
</code></pre>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>具有外键的称为子表(从表),外键被关联的称为父表(主表)</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="sql">-- 添加外键
CREATE TABLE 表名(
    field_name type,
    ...
    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)
)
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名) [ON UPDATE/DELETE 外键约束];

-- 删除外键
ALTER TABLE 表名 DROP FOREIGN KEY 外键字段名;
</code></pre>
<p>外键约束:</p>
<p>NO ACTION 当父表中更新&#x2F;删除时,首先检查是否有外键关联.有则不允许,同RESTRICT</p>
<p>RESTRICT 当父表中更新&#x2F;删除时,首先检查是否有外键关联.有则不允许,同NO ACTION</p>
<p>CASCADE 当删除&#x2F;更新对应记录时,若有对应外键,则也删除&#x2F;更新对应记录(cascade 级联的,逐级的)</p>
<p>SET NULL 当删除对应记录时,若有对应外键,设为NULL(要求该外键允许取NULL)</p>
<p>SET DEFAULT 父表变更时,子表将外键设置为默认值(Innodb不支持)</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果被外键关联,则父表中不可直接删除关联字段,除非解除关联</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="sql">-- 数据准备
create table debt(
    id int auto_increment comment &#39;ID&#39; primary key,
    name varchar(50) not null comment &#39;部门名称&#39;
)comment &#39;部门表&#39;;

insert into dept (id,name) values(1,&#39;研发部&#39;),(2,&#39;市场部&#39;),(3,&#39;财务部&#39;),(4,&#39;销售部&#39;),(5,&#39;总经办&#39;);

create table emp(
    id int auto_increment comment &#39;ID&#39; primary key,
    name varchar(10) not null comment &#39;姓名&#39;,
    job varchar(20) comment &#39;职位&#39;,
    dept_id int comment &#39;部门ID&#39;
)comment &#39;员工表&#39;;

-- 添加外键
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) reference dept(id) on update cascade on delete no action; -- 为本来的字段添加外键
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/sql/" style="color: #ff7d73">sql</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/back-end/" style="color: #03a9f4">back end</a>
        </span>
        
    </div>
    <a href="/2024/09/16/SQL%E5%AD%A6%E4%B9%A0-%E5%9B%9B/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">2</a>
    
    
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">dancingby</div>
        <div class="description">
            <p>Description<br>dancingbyです！</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://github.com/dancingby0">github</a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://afdian.net/a/dancingby">爱发电</a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2024 - 2024 dancingby&#39;s home
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;dancingby
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
